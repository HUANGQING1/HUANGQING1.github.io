<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晴语的博客</title>
  
  <subtitle>2</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-22T05:33:21.195Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>晴语</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/8.html"/>
    <id>http://example.com/blog/8.html</id>
    <published>2024-01-24T09:36:17.874Z</published>
    <updated>2024-02-22T05:33:21.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/102811041</span><br><span class="line">https://blog.csdn.net/weixin_45344328/article/details/123748328</span><br><span class="line">https://zhuanlan.zhihu.com/p/165450634</span><br><span class="line">https://zhuanlan.zhihu.com/p/349054725</span><br><span class="line">(https://zhuanlan.zhihu.com/p/349288830</span><br><span class="line">https://baijiahao.baidu.com/s?id=1722842373056344456</span><br></pre></td></tr></table></figure><h1 id="乐理知识">乐理知识</h1><h2 id="唱名和音名确定蜂鸣器频率">唱名和音名(确定蜂鸣器频率)</h2><h3 id="唱名音符">唱名/音符</h3><p><strong>唱名：</strong>唱名就是这样的do-re-mi-fa-so-la-si这样的七个音，和1234567的7个音符一一对应，常用于简谱。它们和频率有一定关系，但没有绝对的一一对应关系，此处介绍只是科普。<img src="assets/蜂鸣器播放音乐.assets/音符唱名表.png" />、 ###音名(确定蜂鸣器频率) <strong>音名：</strong>也就是C、C#、D、D#、E、F、F#、G、G#、A、A#、B，（C#表示在C的基础上升半音，即频率变为原来的2^(1/12)倍，每个相邻音名相差半音。bC表示在C的基础上降半音。)用于表示特定音高，<strong>音高和蜂鸣器频率是一一对应的关系</strong>，音名常用于五线谱。 <imgsrc="assets/蜂鸣器播放音乐.assets/image-20240125104308475.png" /></p><p>具体如何对应呢，在音乐中以这样的12个音符为一组，多个组循环往复，构成乐音体系的全部乐音，当然实际音乐中所用的乐音为88个(取自钢琴琴键数量)，如图所示，国际规定小字一组的A频率为440Hz。由于相邻半音相差频率2^(1/12)倍，故可推出小字一组的C、C#、D、D#、E、F、F#、G、G#、A、A#、B频率分别为：261.63，277.18，293.66，311.13，329.63，349.23，369.99，392.00，415.30，440，466.16，493.88。其他组的频率依此类推。由于简谱是给人歌唱的，人声音域常在小字一组，故我这里直接以小字一组频率为简谱频率。<imgsrc="assets/蜂鸣器播放音乐.assets/image-20240125112919437.png" /></p><h3id="简谱唱名音符如何对应到音名频率由此将简谱翻译为音名翻译为频率">简谱唱名/音符如何对应到音名(频率)（由此将简谱翻译为音名，翻译为频率）</h3><p>简谱中常见1=C这样的调号，它的意思是1&lt;---&gt;C，2&lt;--&gt;D，...，7&lt;--&gt;B，也常见1=D,1=E这种调号。为什么要有这样的调号呢？我们知道唱名就一定是发do-re-mi-fa-so-la-si-do这样的7个音，do是哪个音高则并无规定，这里就是规定了这7个音对应的音高。这里给出它们对应关系的图片。</p><p><imgsrc="assets/蜂鸣器播放音乐.assets/f690f9795f4573fd19535244e890c22d.jpg" />do-re-mi-fa-so-la-si-do的音高差是规定好的，如上图所示，全音是两个半音。那么1=D时，按照C、C#、D、D#、E、F、F#、G、G#、A、A#、B，以及音高差，很容易就知道2=E、3=F#、4=G、5=A、6=B、7=C#。这样就可以将音符翻译为音名，翻译到频率(取人声音域，也就是小字一组)</p><h2id="节拍和音长确定音符蜂鸣器演奏时长">节拍和音长(确定音符蜂鸣器演奏时长)</h2><h3 id="节拍">节拍</h3><p><strong>节拍：</strong> 简谱中有节拍的概念，拍号通常有<spanclass="math inline">\(\frac{2}{4}、\frac{3}{4}、\frac{3}{8}、\frac{6}{8}\)</span>等等，<spanclass="math inline">\(\frac{X}{Y}\)</span>表示以Y分音符的时长为一拍，每小节有X拍的时长，下图所示的就是以四分音符时长为一拍，每小节有4拍。拍速d=135表示每分钟播放135拍，也就是一拍时长是444ms。<strong>这样每个音符时长就确定下来了</strong>。<img src="assets/蜂鸣器播放音乐.assets/节拍举例图.png" />但显然，图中每个音符到底是几拍目前是不知道的，有些音符上面有点，有些音符下面有点，有些音符下面或后面有短横线，这又是什么意思呢？<strong>音长：</strong>简谱中为了规定每个音的长短，引入了短横线和附点来描述出音长。</p><ul><li><p>短横：在基本音符右侧加记一条短横线表示增长一个四分音符的时值。在基本音符下方加记一条短横线表示缩短原音符时值的一半。假设以四分音符为一拍，那么八分音符就是半拍，十六分音符就是四分之一拍，二分音符是二拍......，如下图所示。<img src="assets/蜂鸣器播放音乐.assets/短横音符.png" /></p></li><li><p>附点音符：附点的意义在于增长原音符时值的一半 <imgsrc="assets/蜂鸣器播放音乐.assets/附点音符.png" /><strong>连线/延音线：</strong>简谱上的弧线叫连线/延音线(在音乐中两者定义是不同的)。每个音符演奏完需要一定停顿，一般不是连续不断的。所以在蜂鸣器中，连线/延音线都表示无需停顿，直接演奏下一音符。</p><p>这里用蜂鸣器模拟声音，就假定是单个音长的1/10用作停顿，单个音符的音长划分为实际播放时间+停顿时间。</p><p><img src="assets/蜂鸣器播放音乐.assets/连音线.png" /><strong>休止符0：</strong> 音乐中，休止符表示无声。 # 代码编写总的来说，一段音乐由两部分组成，频率和音长。其中音长又可分为播放时间和停顿时间。在此以音长的1/10为停顿时间。由于是翻译简谱，简谱翻译中采用人声音域，中音小字一组，低音小字组，高音小字二组。</p></li></ul><p>设计类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">Song类：</span><br><span class="line">属性：调号、拍号、拍速、简谱正文</span><br><span class="line">方法：初始化函数、将正文转换为频率和时长的函数</span><br><span class="line"></span><br><span class="line">Note类：</span><br><span class="line">属性：简谱音符、音调、拍数、是否休止,是否升调</span><br><span class="line">方法：初始化函数</span><br><span class="line"></span><br><span class="line">Buzzer类：</span><br><span class="line">属性：引脚</span><br><span class="line">方法：播放音符函数、停止函数、延时函数</span><br><span class="line"></span><br><span class="line">MusicPlayer类（主类）：</span><br><span class="line">方法：播放歌曲函数，接收Song对象，通过Buzzer对象播放</span><br><span class="line"></span><br><span class="line">from machine import Pin  # 假设你的蜂鸣器控制是基于MicroPython的machine库</span><br><span class="line"></span><br><span class="line">from machine import Pin</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class Note:</span><br><span class="line">    def __init__(self, symbol=0, beats=1, is_rest=True, pitch=0):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        简谱音符的类</span><br><span class="line">        :param symbol: 音符（0-7）</span><br><span class="line">        :param beats: 拍数（小数），比如一拍是1，四分之一拍是0.25</span><br><span class="line">        :param is_rest: 是否休止（True/False）</span><br><span class="line">        :param pitch: 0（中音), 1(高音), -1(低音), ...</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.symbol = symbol</span><br><span class="line">        self.beats = beats</span><br><span class="line">        self.is_rest = is_rest</span><br><span class="line">        self.pitch = pitch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Song:</span><br><span class="line">    def __init__(self, key=&quot;C&quot;, tempo=150, notes=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        歌曲的类</span><br><span class="line">        :param key: 调号，默认为C</span><br><span class="line">        :param tempo: 拍度，默认为150</span><br><span class="line">        :param notes: 简谱音符序列</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.key = key</span><br><span class="line">        self.tempo = tempo</span><br><span class="line">        self.notes = notes if notes else []</span><br><span class="line"></span><br><span class="line">    def convert_to_frequency(self, note):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将简谱音符转换为频率</span><br><span class="line">        :param note: 简谱音符对象</span><br><span class="line">        :return: 频率</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 调号对应偏移</span><br><span class="line">        key_to_offset = &#123;&#x27;C&#x27;: -9, &#x27;D&#x27;: -7, &#x27;E&#x27;: -5, &#x27;F&#x27;: -4, &#x27;G&#x27;: -2, &#x27;A&#x27;: 0, &#x27;B&#x27;: 2&#125;</span><br><span class="line">        # 音符对应偏移</span><br><span class="line">        symbol_to_offset = &#123;1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11&#125;</span><br><span class="line">        frequency = 440  # 标准音频率</span><br><span class="line">        if note.symbol == 0:  # 休止符频率为0</span><br><span class="line">            frequency = 0</span><br><span class="line">        else:</span><br><span class="line">            # 计算&quot;C&quot;的频率</span><br><span class="line">            frequency *= 2 ** (key_to_offset[self.key] / 12)</span><br><span class="line">            # 不考虑音调升降，计算该音符频率</span><br><span class="line">            frequency *= 2 ** (symbol_to_offset[note.symbol] / 12)</span><br><span class="line">            # 考虑音调升降</span><br><span class="line">            frequency *= 2 ** note.pitch</span><br><span class="line"></span><br><span class="line">        return frequency</span><br><span class="line"></span><br><span class="line">    def get_duration(self, note):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        根据拍数和拍度计算时长, ms</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        duration = int(60000 / self.tempo * note.beats)  # 转换为整数型</span><br><span class="line">        return duration</span><br><span class="line"></span><br><span class="line">    def convert_to_music_text(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将音符转换为音乐文本</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        music_text = []</span><br><span class="line">        for note in self.notes:</span><br><span class="line">            frequency = self.convert_to_frequency(note)</span><br><span class="line">            duration = self.get_duration(note)</span><br><span class="line">            is_rest = note.is_rest</span><br><span class="line">            music_text.append([frequency, duration, is_rest])</span><br><span class="line"></span><br><span class="line">        return music_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Buzzer:</span><br><span class="line">    def __init__(self, pin=15):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        蜂鸣器的类</span><br><span class="line">        :param pin: 引脚，默认为15</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.pin = Pin(pin, Pin.OUT)</span><br><span class="line"></span><br><span class="line">    def play_note(self, frequency, duration, is_rest):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        播放特定频率的音符</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        time_ms = 0</span><br><span class="line">        play_time_ms = duration</span><br><span class="line">        delay_us = int(500000 / frequency)</span><br><span class="line"></span><br><span class="line">        if is_rest:</span><br><span class="line">            play_time_ms = int(duration * 0.9)</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            if time_ms &lt; play_time_ms:</span><br><span class="line">                self.pin.value(1)</span><br><span class="line">                time.sleep_us(delay_us)</span><br><span class="line">                self.pin.value(0)</span><br><span class="line">                time.sleep_us(delay_us)</span><br><span class="line">                time_ms += int(delay_us / 1000)</span><br><span class="line">            elif time_ms &lt; duration:</span><br><span class="line">                self.pin.value(0)</span><br><span class="line">            elif time_ms == duration:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MusicPlayer:</span><br><span class="line">    def __init__(self, buzzer):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        音乐播放器的类</span><br><span class="line">        :param buzzer: Buzzer对象</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.buzzer = buzzer</span><br><span class="line"></span><br><span class="line">    def play_song(self, song):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        播放歌曲</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for frequency, duration, is_rest in song.convert_to_music_text():</span><br><span class="line">            self.buzzer.play_note(frequency, duration, is_rest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def time0_irq(time0):</span><br><span class="line">    global time_ms</span><br><span class="line">    time_ms += 1  # 修正语法错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">from machine import Pin</span><br><span class="line"></span><br><span class="line">class Beep:</span><br><span class="line">    # 默认的蜂鸣器引脚为GPIO15</span><br><span class="line">    BeepPin = Pin(15, Pin.OUT)</span><br><span class="line"></span><br><span class="line">    def __init__(self, frequency, duration, is_rest=False):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化蜂鸣器对象。</span><br><span class="line"></span><br><span class="line">        Parameters:</span><br><span class="line">        - frequency: int, 频率表示音高。</span><br><span class="line">        - duration: int, 音长表示音符持续时间us。</span><br><span class="line">        - is_rest: bool, 是否是停顿。默认为 False。</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.frequency = frequency</span><br><span class="line">        self.duration = duration</span><br><span class="line">        self.is_rest = is_rest</span><br><span class="line">  </span><br><span class="line">def play_note(self): </span><br><span class="line">pause_us=500000/self.frequency;//取整</span><br><span class="line">self.BeepPin.value(1);</span><br><span class="line">time.sleep_us(pause_us);</span><br><span class="line">self.BeepPin.value(0);</span><br><span class="line">time.sleep_us(pause_us);</span><br><span class="line">歌曲包含：调号，拍号，拍速，简谱正文，蜂鸣器播放正文 几部分</span><br><span class="line">简谱正文：[简谱音符，拍数]</span><br><span class="line">歌曲中有一个函数，输入调号和简谱音符，将得到简谱音符对应频率</span><br><span class="line">歌曲中有一个函数，输入拍速和拍数，将得到拍数对应时长</span><br><span class="line">歌曲有函数将正文转换为由频率和时长，是否休止构成的新正文</span><br><span class="line"></span><br><span class="line">简谱音符包括下面几部分：简谱音符，拍数，是否休止，</span><br><span class="line"></span><br><span class="line">蜂鸣器包括：引脚</span><br><span class="line">播放音符函数：以一定频率播放音符</span><br><span class="line">停止函数：停止播放</span><br><span class="line">延时函数：延时指定时间</span><br><span class="line">播放歌曲函数：接收由频率，时长，是否休止构成的正文，通过蜂鸣器播放出来</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/10.html"/>
    <id>http://example.com/blog/10.html</id>
    <published>2024-01-24T08:09:04.442Z</published>
    <updated>2024-02-22T05:33:21.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境">开发环境</h1><h2 id="简介">简介</h2><ul><li>ESP32的通用开发环境有：ESP-IDF，使用C/C++语言开发，比较复杂麻烦</li><li>VSCode+插件Platform IDE开发/或Micro python(Thonny软件)开发</li><li>arduino IDE开发</li></ul><p>我是使用MicroPython,Thonny软件开发的。</p><h2 id="软件下载安装">软件下载安装</h2><ul><li>Tonny软件下载：https://thonny.org/</li><li>MicroPython下载:https://micropython.org/download/esp32/</li><li>参考教程：https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html</li></ul><h1 id="参考教程">参考教程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ESP32学习教程：https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html 或普中的esp32书（Zlibrary有下载）</span><br><span class="line">MicroPython官方的文档：http://docs.micropython.org/en/latest/esp32/quickref.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发环境&quot;&gt;开发环境&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ESP32的通用开发环境有：ESP-IDF，使用C/C++语言开发，比较复杂麻烦&lt;/li&gt;
&lt;li&gt;VSCode+插件Platform IDE开发/或Micro py</summary>
      
    
    
    
    <category term="工具软件使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/5.html"/>
    <id>http://example.com/blog/5.html</id>
    <published>2024-01-23T06:01:26.050Z</published>
    <updated>2024-02-22T05:33:21.193Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">uname -r #显示系统相关内核版本号</span><br><span class="line">cat /etc/os-release #命令用于显示操作系统的信息</span><br><span class="line"></span><br><span class="line">curl localhost:3344</span><br><span class="line"></span><br><span class="line">docker status 容器id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum remove xxx yyy zzz</span><br><span class="line">yum install -y xxx yyy zzz</span><br><span class="line">yum-config-manager -add-repo xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br><span class="line">docker images</span><br><span class="line">docker ps</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker 命令 --help </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker images查看所有本地的主机上的镜像</span><br><span class="line"></span><br><span class="line">docker search 搜索镜像</span><br><span class="line">docker search 搜索镜像</span><br><span class="line">docker pull下载镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#卸载docker</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">rm -rf /var/lib/docker #/var/lib/docker是docker的默认工作路径</span><br></pre></td></tr></table></figure><h1 id="docker概述">Docker概述</h1><p>Docker是一种容器化技术，通过将应用程序及其所有依赖项打包到一个独立的容器中，实现了轻量、快速、一致的应用部署，提高了开发、测试和部署的效率。</p><p>Docker像是轻量的虚拟机，为安装在其内的应用程序提供互相隔离的环境，避免了配置环境的麻烦。</p><h1 id="docker安装">Docker安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#1、卸载旧的版本</span><br><span class="line">yum remove docker \</span><br><span class="line">                    docker-client \</span><br><span class="line">                    docker-client-latest \</span><br><span class="line">                    docker-common \</span><br><span class="line">                    docker-latest \</span><br><span class="line">                    docker-latest-logrotate \</span><br><span class="line">                    docker-logrotate \</span><br><span class="line">                    docker-engine</span><br><span class="line"></span><br><span class="line">#2、下载需要的安装包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3、设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://down1oad.docker.com/linux/centos/docker-ce.repo #默认是从国外的!</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/1inux/centos/docker-ce.repo #推荐使用阿里云的，十分的快</span><br><span class="line"></span><br><span class="line">#更新yum软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">#4、安装dokcer docker-ce社区ee企业版</span><br><span class="line">yum insta1l docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">#5、启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#7、he11o-wor1d 测试docker是否安装成功，安装成功会重新Hello from Docker!字样</span><br><span class="line">docker run he11o-wor1d</span><br><span class="line"></span><br><span class="line">#8、查看一下下载的这个hello-wor1d镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 9、了解:卸载docker</span><br><span class="line">##9.1、卸载依赖</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">##9.2、册除资源</span><br><span class="line">rm -rf /var/1ib/docker</span><br><span class="line">#/var/1ib/docker docker的默认工作路径!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#需要加速的话，配置镜像加速器。</span><br></pre></td></tr></table></figure><h1 id="docker命令">Docker命令</h1><h2 id="帮助命令">帮助命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version # 显示docker的版本信息</span><br><span class="line">docker info #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help  #帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档的地址:https:/ldocs.docker.com/engine/referencelcommandline/</p><h2 id="镜像命令">镜像命令</h2><h3 id="docker-images查看镜像">docker images查看镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看所有本地的主机上的镜像</span><br><span class="line">#可选项</span><br><span class="line">-a, --a11#列出所有镜像</span><br><span class="line">-q,--quiet#只显示镜像的id</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="docker-search搜索镜像">docker search搜索镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql #搜索mysql镜像</span><br><span class="line"></span><br><span class="line">#可选项,通过搜藏来过滤</span><br><span class="line">docker search mysql --filter=STARS=3000#搜索出来的镜像就是STARS大于3000的</span><br></pre></td></tr></table></figure><h3 id="docker-pull下载镜像">docker pull下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pu1l 镜像名[:tag]  #下载镜像,tag是可选版本名，默认是下载最新版本，docker pu1l 镜像名:latest</span><br><span class="line">docker pu11 mysql</span><br><span class="line">docker pull mysql:5.7 #下载mysql5.7版本</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="docker-rmi删除镜像">docker rmi删除镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像id#删除指定的镜像</span><br><span class="line">docker rmi -f 镜像1id 镜像2id 镜像3 id 镜像4id #删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq)#删除全部的镜像</span><br></pre></td></tr></table></figure><h2 id="容器命令">容器命令</h2><h3 id="新建容器并启动docker-run">新建容器并启动docker run</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line">#举例，启动并进入容器。以启动centos容器为例，以bat命令行发生打开</span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line">#注意，如果以后台方式运行容器，容器启动后又没有提供服务，自行终止</span><br><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02，用来区分容器</span><br><span class="line">-d 后台方式运行</span><br><span class="line">-it 使用交互方式运行,进入容器查看内容</span><br><span class="line">-p指定容器的端口-p 8080:8080</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p主机端口:容器端口（常用）-p容器端口</span><br><span class="line">容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列出所有的运行的容器docker-ps">列出所有的运行的容器dockerps</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps#列出当前正在运行的容器</span><br><span class="line">docker ps -a#列出当前正在运行的容器+带出历史运行过的容器</span><br><span class="line">docker ps -n=?#显示最近创建的容器</span><br><span class="line">docker ps -q#只显示容器的编号</span><br></pre></td></tr></table></figure><h3 id="退出容器">退出容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit#直接让容器停止并退出</span><br><span class="line">Ctrl +P+Q#容器不停止退出</span><br></pre></td></tr></table></figure><h3 id="删除容器docker-rm">删除容器docker rm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id   #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)#删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm#册除所有的容器</span><br></pre></td></tr></table></figure><h3 id="启动和停止容器的操作">启动和停止容器的操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id#启动容器</span><br><span class="line">docker restart 容器id#重启容器</span><br><span class="line">docker stop 容器id#停止当前正在运行的容器</span><br><span class="line">docker ki1l 容器id#强制停止当前容器</span><br></pre></td></tr></table></figure><h3 id="查看日志docker-logsdocker-logs">查看日志docker logsdockerlogs</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#参数说明</span><br><span class="line">-tf#显示日志</span><br><span class="line">--tail number#显示日志条数</span><br><span class="line">#举例</span><br><span class="line">docker logs -tf --tail 10 容器id #显示容器id对应的最近10条记录</span><br></pre></td></tr></table></figure><h3 id="查看容器中进程信息docker-top">查看容器中进程信息docker top</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure><h3 id="查看镜像的元数据docker-inspec">查看镜像的元数据dockerinspec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><h3 id="进入当前正在运行的容器">进入当前正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><br><span class="line">docker exec -it 容器id /bin/bash  </span><br><span class="line">docker attach 容器id </span><br><span class="line"></span><br><span class="line">#两者区别</span><br><span class="line"># docker exec 进入容器后开启一个新的终端，可以在里面操作（常用)</span><br><span class="line">#docker attach 进入容器正在执行的终端,不会启动新的进程!</span><br></pre></td></tr></table></figure><h3 id="从容器内拷贝文件到主机上">从容器内拷贝文件到主机上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径目的的 主机路径</span><br></pre></td></tr></table></figure><h2 id="命令汇总">命令汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">attachAttach to a running container#当前she1l 下attach连接指定运行镜像</span><br><span class="line">bui1dBui1d an image from a Dockerfile#通过Dockerfile定制镜像</span><br><span class="line">commit Create a new image from a container changes#提交当前容器为新的镜像</span><br><span class="line">cpcopy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目</span><br><span class="line">录到宿主机中</span><br><span class="line">createCreate a new container#创建一个新的容器,同run，但不启动容器</span><br><span class="line">diffInspect changes on a container &#x27;s filesystem#查看docker容器变化</span><br><span class="line">events Get real time events from the server#从docker服务获取容器实时事件</span><br><span class="line">exec Run a command in an existing container#在已存在的容器上运行命令</span><br><span class="line">exportStream the contents of a container as a tar archive#导出容器的内容流作为一个 tar 归档文件[对应import]</span><br><span class="line">history show the history of an image#展示一个镜像形成历史</span><br><span class="line">imagesList images#列出系统当前镜像</span><br><span class="line">import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line">infoDisplay system-wide information#显示系统相关信息</span><br><span class="line">inspect Return low-1eve1 information on a container#查看容器详细信息</span><br><span class="line">killKill a running container#kill指定docker容器</span><br><span class="line">1oadLoad an image from a tar archive#从一个tar包中加载一个镜像[对应save]</span><br><span class="line">login Register or Login to the docker registry server#注册或者登陆一个docker 源服务器</span><br><span class="line">1ogout Log out from a Docker registry server#从当前Docker registry 退出</span><br><span class="line">1ogsFetch the logs of a container#输出当前容器日志信息</span><br><span class="line">port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT#查看映射端口对应的容器内部源端口</span><br><span class="line">pausePause all processes within a container#暂停容器</span><br><span class="line">psList containers#列出容器列表</span><br><span class="line">pu11Pull an image or a repository from the docker registry server# 从docker镜像源服务器拉取指定镜</span><br><span class="line">像或者库镜像</span><br><span class="line">pushPush an image or a repository to the docker registry server#推送指定镜像或者库镜像至docker源</span><br><span class="line">服务器</span><br><span class="line">restartRestart a running container#重启运行的容器</span><br><span class="line">rmRemove one or more containers#移除一个或者多个容器</span><br><span class="line">rmiRemove one or more images#移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容</span><br><span class="line">器才可继续或-f强制册除]</span><br><span class="line">runRun a command in a new container#创建一个新的容器并运行一个命令</span><br><span class="line">saveSave an image to a tar archive#保存一个镜像为一个 tar包[对应load]</span><br><span class="line">searchSearch for an image on the Docker Hub#在docker hub中搜索镜像</span><br><span class="line">startStart a stopped containers#启动容器</span><br><span class="line">stopStop a running containers#停止容器</span><br><span class="line">tagTag an image into a repository#给源中镜像打标签</span><br><span class="line">topLookup the running processes of a container#查看容器中运行的进程信息</span><br><span class="line">unpause Unpause a paused container#取消暂停容器</span><br><span class="line">version show the docker version information#查看docker版本号</span><br><span class="line">waitBlock until a container stops，then print its exit code # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure><h1id="docker图形化界面管理工具portainer">Docker图形化界面管理工具portainer</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v/var/run/docker.sock: /var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><h1 id="section"></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="工具软件使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/9.html"/>
    <id>http://example.com/blog/9.html</id>
    <published>2024-01-17T03:02:44.988Z</published>
    <updated>2024-02-22T05:33:21.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tm1650">TM1650</h1><ul><li>标准IIC协议通信</li><li>有数据输出，驱动灯。键盘扫描，读取矩阵键盘能力。</li><li>操作流程(如下图所示)：<ul><li><img src="assets/非主控芯片.assets/TM1650操作流程图.png" /></li><li>Step1：设置系统命令48H，设置系统参数<ul><li>系统参数如何取值<ul><li>如图所示，如果选择7级别亮度，则B7-B4为0111，选择8段工作B3为0，选择正常工作B2为0，选择开显示B1-B0为01，合计01110001，即71H。</li><li><img src="assets/非主控芯片.assets/TM1650系统参数设置.png" /></li></ul></li></ul></li><li><strong>Step2(可选)：</strong>设置显示地址1，设置显示数据1。设置显示地址2，设置显示数据2。设置显示地址3，设置显示数据3。....</li><li><strong>Step3(可选)：</strong>发送读取命令4FH，读取按键数据1，读取按键数据2，读取按键数据3...</li></ul></li></ul><h1 id="rs485芯片">RS485芯片</h1><ul><li>一般有<spanclass="math inline">\(RO,\overline{RE},DE,DI\)</span>四个引脚</li><li>RO是从芯片外部输入到芯片的一端，接芯片的RX脚</li><li><spanclass="math inline">\(\overline{RE}\)</span>，低电平有效，给RO使能</li><li>DI是从芯片内部输出到芯片外的一端，接芯片的TX脚</li><li><span class="math inline">\(DE\)</span>，高电平有效，给DI使能</li><li>一般将<spanclass="math inline">\(\overline{RE},DE\)</span>接在同一根线上，发送时高电平，接收时低电平。其余的部分就与普通UART通信完全一致。</li><li>也有的将<spanclass="math inline">\(\overline{RE},DE,DI\)</span>都与UART_TX连接，实现自动收发（平时是低电平RX接收模式，当要发送数据时，TX会有高低电平输出，自动给<spanclass="math inline">\(DE\)</span>高电平使能，进入发送模式。）</li></ul><h1 id="tm1812">TM1812</h1><ul><li>256级调光，可级联，12个PWM控制输出引脚。</li><li>比较麻烦的地方：0/1码的高低电平时间以ns为衡量单位。<ul><li>实际编程发现，1.25us周期可无视，高电平时间满足要求即可。</li><li>在预编译中，多个nop组成延时函数，这样可以避免编译器优化，时间不对。# FR0396</li></ul></li><li>没什么复杂的，高低电平输出就行了。 # HSU-CHM-01A温湿度传感器</li><li>数据手册很难找</li><li>标准IIC通信</li><li>有写模式和读模式，7位设备地址固定为0X7F</li><li>写数据时，安照IIC通信，先后写入地址，寄存器地址，寄存器值。用来设置芯片工作模式。举例，先写0X7F</li><li>读数据时，先后写入地址，寄存器地址，然后读取寄存器值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tm1650&quot;&gt;TM1650&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;标准IIC协议通信&lt;/li&gt;
&lt;li&gt;有数据输出，驱动灯。键盘扫描，读取矩阵键盘能力。&lt;/li&gt;
&lt;li&gt;操作流程(如下图所示)：
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;assets/非主控芯片</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/1.html"/>
    <id>http://example.com/blog/1.html</id>
    <published>2024-01-15T07:59:15.864Z</published>
    <updated>2024-02-22T05:33:21.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资源">参考资源</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">书：</span><br><span class="line">深入浅出STM8单片机入门、进阶与应用实例（比较啰嗦全面，看视频吧，书不建议，寄存器版本）</span><br><span class="line">STM8单片机自学笔记（简洁易懂，寄存器版本。库函数版本）</span><br><span class="line"></span><br><span class="line">软件：</span><br><span class="line">STVD开发</span><br><span class="line">IAR开发</span><br><span class="line">STVP烧录固件</span><br><span class="line"></span><br><span class="line">工具：ST-LINK仿真烧录器</span><br><span class="line"></span><br><span class="line">数据手册下载网站：：https://www.alldatasheet.com,官网</span><br></pre></td></tr></table></figure><h1 id="时钟">时钟</h1><p><strong>STM8单片机默认使用HSI RC时钟的8分频，即2 MHz</strong> ##*STM8的时钟源 STM8有四个可选时钟源： - 1~24MHz高速外部晶体振荡器(HSE,High Speed External crystal); - 最大24MHz高速外部时钟信号(HSE user - ext); - 16 MHz高速内部RC振荡器(HSI,HighSpeed Internal RC oscillator); - 128 kHz低速内部RC振荡器(LSI,LowSpeedInternal RC)。 具体内容，参考书本，此处不过多解释。 ### HSI(最常用)相关寄存器： - CLK_CKDIVR分频因子 -CLK_ICKR的标志位HSIRDY，指示HSI是否稳定 -CLK_ICKR的HSIEN使能位，负责打开关闭HSI ### LSI低功耗，低成本时钟源，可用于停机模式维持独立看门狗，或自动唤醒单元AWU相关寄存器： - CLK_ICKR的LSIEN使能位，负责打开关闭LSI -CLK_ICKR的LSIRDY标志位，指示LSI是否稳定 ## 示例代码（HSI,寄存器版本)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostm8s005k6.h&quot;</span><br><span class="line">void CLK_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_CKDIVR=0X00;//HSI不分频，单片机工作在16 MHz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_Config();</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure> ## 示例代码（HSI,库函数版本） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm8s.h&quot;</span><br><span class="line">#include &quot;stm8s_clk.h&quot;</span><br><span class="line">void CLK_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);//HSI不分频，单片机工作在16 MHz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_Config();</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h1 id="gpio">GPIO</h1><h3 id="支持的gpio配置模式">支持的GPIO配置模式</h3><p><imgsrc="assets/STM8单片机.assets/STM8单片机GPIO资源支持的配置模式.png" /></p><h2 id="推挽开漏上拉悬浮详解">推挽、开漏、上拉、悬浮详解</h2><p><strong>悬浮输入：</strong>引脚电平状态不确定，易受外界影响，适用于部电压采集，A/D模数转换。<strong>上拉输入：</strong>连接上拉电阻，稳定电平，减少外界干扰。应用于外部按键。<strong>推挽输出：</strong>输出确定的高低电平，由于接了上拉/下拉电阻，所以可以借此提高负载驱动能力，提高开关速度。<strong>开漏输出：</strong>自身无法输出确定的高电平，只能输出低电平。仅可通过外接外部上拉电阻来输出高电平。优点是低功耗，电平转换。## 相关寄存器 每个GPI0端口都分配有五个寄存器: - 输出数据寄存器 Px_ODR -输入数据寄存器 Px_IDR - 数据方向寄存器 Px_DDR - 控制寄存器1 Px_CR1 -控制寄存器2 Px_CR2 （x表示端口组，取A~I) DDR为0表示输入，为1表示输出输入模式中：CR1为0表示悬浮，为1表示上拉输出模式中：CR1为0表示开漏，为1表示推挽输入模式中：CR2为0表是不开启中断，为1表示开启中断输出模式中：CR2为0表示不采取快速模式，为1表示采取快速模式</p><p>在进行读操作是我们通过读取寄存器IDR的值获取引脚的电平状态，通过改变寄存器ODR的值进行输出。<img src="assets/STM8单片机.assets/STM8单片机GPIO配置表.png"alt="STM8单片机GPIO配置表" /> ## 示例代码（寄存器版本)配置PB4~PB7为悬浮输入模式; PB0~PB3为弱上拉输入模式;读取PB端口状态赋值给变量“x”; 读取单一端口PB2状态赋值给变量“y”:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostm8s005k6.h&quot;</span><br><span class="line"></span><br><span class="line">void GPIO_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">PB_DDR =0x00;//对应二进制为“0000 0000”， PB全端口均为输入模式</span><br><span class="line">PB_CR1=0x0F;//对应二进制为“0000 1111” ，PB4~PB7悬浮输入，PB0~PB3上拉输入</span><br><span class="line">PB_CR2=0X00;//不开启中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char x,y;</span><br><span class="line"></span><br><span class="line">//使用默认时钟，不做配置</span><br><span class="line">GPIO_Config();</span><br><span class="line">x=PB_IDR; //读取PB端口状态并赋值给变量“x”</span><br><span class="line">y= (PB_IDR&gt;&gt;2)&amp;0x01; //读取PB2端口状态并赋值给变量“x”(理解一下位运算和&amp;就知道为什么这么写了)</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure> 配置PB组GPI0端口高4位为2MHz速率开漏输出模式，低4位为10MHz速率推挽输出模式，让端口输出“0101 0111” 电平状态: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostm8s005k6.h&quot;</span><br><span class="line">void GPIO_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">PB_DDR =0xFF;//对应二进制为“1111 1111”， PB全端口均为输出模式</span><br><span class="line">PB_CR1=0x0F;//对应二进制为“0000 1111”，高4位(PB7-PB4)开漏输出，低4位(PB3-PB0)推挽输出</span><br><span class="line">PB_CR2=0x0F;//对应二进制为“0000 1111” ，高4位2MHz速率，低4位10MHz速率</span><br><span class="line">PB_ODR= 0x57;//对应二进制为“0101 0111” ，即为用户自定义初始输出状态数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">//使用默认时钟，不做配置</span><br><span class="line">GPIO_Config();</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>Stm8中进行位操作也有如同51中P1_1这样的用法，是在头文件例如iostm8s005k6.h中定义好的。## 示例代码（库函数版本） 配置PB4~PB7为悬浮输入模式;PB0~PB3为弱上拉输入模式; 读取PB端口状态赋值给变量“x”;读取单一端口PB2状态赋值给变量“y”: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm8s.h&quot;</span><br><span class="line">#include &quot;stm8s_gpio.h&quot;</span><br><span class="line"></span><br><span class="line">void GPIO_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">//配置PB4~PB7为悬浮输入模式</span><br><span class="line">GPIO_Init(GPIOB, GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7, GPIO_MODE_IN_FL_NO_IT );</span><br><span class="line">//PB0~PB3为弱上拉输入模式</span><br><span class="line">GPIO_Init(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_MODE_IN_PU_NO_IT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        u8 x,y;</span><br><span class="line">//使用默认时钟，不做配置</span><br><span class="line">GPIO_Config();</span><br><span class="line">x=GPIO_ReadInputData(GPIOB); //读取PB端口状态并赋值给变量“x”</span><br><span class="line">y= GPIO_ReadInputPin(GPIOB,GPIO_PIN_2); //读取PB2端口状态并赋值给变量“x”(理解一下位运算和&amp;就知道为什么这么写了)</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h1 id="中断">中断</h1><h2 id="中断类型">中断类型</h2><p>STM8可处理的中断分为两类： -<strong>不可屏蔽中断</strong>，无法关闭，只要发生CPU必须去处理 -<strong>可屏蔽中断</strong>，可以关闭，通过下面代码可以关闭开启 -asm("sim"); //关闭系统总中断 - asm("rim"); //打开系统总中断可屏蔽中断有内嵌的外部中断（定时器中断，ADC中断等等），IO口外部中断（比如检测到高电平触发中断，或者检测到低电平，上升/下降沿）## 中断管理模式 STM8有两种中断管理模式： -<strong>非嵌套模式</strong>，所有可屏蔽中断同软件中断优先级，因而不可抢占- <strong>嵌套模式</strong>，有不同软件中断优先级，因而可抢占中断优先级有软件中断优先级和硬件中断优先级之分，具体不必细究(计算机组成原理有讲解)，软件中断可由程序员配置，硬件中断出厂确定无可更改。<strong>中断的判断逻辑如下：</strong> -谁先发生，谁先中断（无其他中断执行） -同时发生，先比较软件中断优先级，优先级高的先执行，如果软件中断优先级相同，比较硬件中断优先级，优先级高的先执行。（无其他中断执行）-假设A中断正执行，B中断发生，比较软件中断优先级。若B的软件优先级高于A，B中断可以打断A，抢占到CPU，先执行。若B的软件优先级不高于A，必须等待A中断执行完毕，才能继续争夺CPU。## 相关寄存器 - CPU条件寄存器CCR -软件优先级寄存器ITC_SPRx，设置外部中断的软件中断优先级 -外部中断控制寄存器EXTI_CR1、EXTI_CR2，设置外部中断触发方式（下降沿，上升沿，高低电平触发）## 示例代码(UART中断) ## 示例代码(TIM4中断)</p><h1 id="基本定时器tim4">基本定时器TIM4</h1><p>STM8中TIM4的时钟源来自于系统时钟<spanclass="math inline">\(f_{MASTER}\)</span> ，<spanclass="math inline">\(f_{MASTER}\)</span> 默认是HSI的8分频2 MHz。 ##相关寄存器 - TIM4_CR1控制寄存器：<imgsrc="assets/STM8单片机.assets/STM8的TIM4_CR1寄存器.png" /> -ARPE位置1，使能自动预装载 - CEN位置1，使能计数器，使计数器开始计数 -TIM4_IER中断使能寄存器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_IER寄存器.png" /> -UIE位置1，打开定时器4中断 - TIM4_SR1状态寄存器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_SR1寄存器.png" /> -UIF位置1，说明发生溢出，定时器中断被触发。会执行定时器中断函数（执行中断函数时，要清零UIF位，否则会循环一直执行中断函数)。- TIM4_EGR事件产生寄存器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_EGR寄存器.png" /> -TIM4_CNTR计数器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_CNTR寄存器.png" /> -TIM4_CNTR存放计数值 - TIM4_PSCR预分频寄存器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_PSCR寄存器.png" /> -用于预分频，确定计数器每过去多少时间加1 - PSC[2:0]，有三位，可取值0-7 -定时器频率=<spanclass="math inline">\(\frac{f_{MASTER}}{2^{PSC[2:0]}}\)</span> -比如如果主频是16 MHz，PSC[2:0]设为7，那么定时器时钟频率就是16MHz/2^7=125KHz - TIM4_ARR自动重装载寄存器<imgsrc="assets/STM8单片机.assets/STM8的TIM4_ARR寄存器.png" /> -确认计数器的计数最大值，当计数器值超过此最大值，将触发定时器中断。 ##定时器的工作过程 - 计数器 有一个初值，假设是5吧 -有一个计数器(CNTR)，第一次计数从初值5开始数数，每隔一段时间加1， -有一个计数器最大值(ARR)，假设是200吧，计数器达到200，会判定发生溢出，将标志位置1-有一个标志位(UIF)，用来判断计数器的值是否达到200，达到后会执行设定的相关事件(中断处理函数)- 事件执行完后，计数器从0开始计数，重复上述行为。</p><h2 id="示例代码寄存器版本">示例代码（寄存器版本)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostm8s005k6.h&quot;</span><br><span class="line"></span><br><span class="line">void TIM4_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">TIM4_IER=0x00;          //先关闭定时器4中断</span><br><span class="line">TIM4_EGR = 0x00;        //</span><br><span class="line">TIM4_PSCR = 7;          //定时器4时钟=16MHz/2^7=125KHZ </span><br><span class="line">//125KHZ意味着，计数器每隔1/125K s加1，计数125次，时间过去1ms。 </span><br><span class="line">TIM4_ARR = 125;         //设定1定时器产生1毫秒重装载时的计数值，255是最大值</span><br><span class="line">TIM4_CNTR = 0x00;       //设定计数器的初值为0</span><br><span class="line">TIM4_SR=0x00;            //清除中断标志位</span><br><span class="line">TIM4_CR1|=0x81;           //使能定时器4，开始计数、使能自动预装载</span><br><span class="line">TIM4_IER |= 0x01;           //打开定时器中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">asm(&quot;sim&quot;);                     //关闭系统总中断</span><br><span class="line">CLK_CKDIVR = 0x00;              //CPUDIV = 1 HSIDIV = 1  内部时钟 = 16Mhz</span><br><span class="line">TIM4_Config();</span><br><span class="line">asm(&quot;rim&quot;); //打开系统总中断</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma vector = 25     //设置定时器4重载的中断向量号 = 25</span><br><span class="line">__interrupt void TIM4_UPDATE_IRQHandler(void)//定时器4中断处理函数</span><br><span class="line">&#123;</span><br><span class="line">TIM4_SR = 0x00;  //清除中断标志UIF</span><br><span class="line">//自定义代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="示例代码库函数版本">示例代码（库函数版本）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm8s.h&quot;</span><br><span class="line">#include &quot;stm8s_tim4.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TIM4_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">TIM4_DeInit();//重置回默认值</span><br><span class="line">TIM4_TimeBaseInit(TIM4_PRESCALER_128,125);//定时器4时钟=16MHz/2^7=125KHZ ，设定1定时器产生1毫秒重装载时的计数值，255是最大值</span><br><span class="line">TIM4_SetCounter(0);//可省略，计数器的默认初值本就为0</span><br><span class="line">TIM4_ARRPreloadConfig(ENABLE);//使能自动预装载，也不是必须有的</span><br><span class="line">TIM4_ITConfig(TIM4_IT_UPDATE,ENABLE );//打开定时器中断</span><br><span class="line">TIM4_Cmd(ENABLE);//使能定时器4,开始计数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CLK_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);//HSI不分频，单片机工作在16 MHz</span><br><span class="line">&#125;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">asm(&quot;sim&quot;);                     //关闭系统总中断</span><br><span class="line">CLK_Config();              //CPUDIV = 1 HSIDIV = 1  内部时钟 = 16Mhz</span><br><span class="line">TIM4_Config();</span><br><span class="line">asm(&quot;rim&quot;); //打开系统总中断</span><br><span class="line">while(1);//死循环，防止程序跑飞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma vector = 25     //设置定时器4重载的中断向量号 = 25</span><br><span class="line">__interrupt void TIM4_UPDATE_IRQHandler(void)//定时器4中断处理函数</span><br><span class="line">&#123;</span><br><span class="line">TIM4_ClearITPendingBit(TIM4_IT_UPDATE);  //清除中断标志UIF</span><br><span class="line">//自定义代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h1 id="高级控制定时器tim1">高级控制定时器TIM1</h1><h1 id="uart">UART</h1><h2 id="串口通信">串口通信</h2><p>串口通信（Serialcommunication）是一种通信方式，通过串行（逐位）传输数据。它是计算机和其他设备之间传输数据的常用方法。串口通信有多种类型，如UART（通用异步收发器）、SPI（串行外设接口）、I2C（内部集成电路总线）等。## 定义</p><p>UART（通用异步收发器）是一种异步串行通信协议，使用两个数据线进行通信：TX（发送）和RX（接收）。UART 通信具有以下特点：</p><ul><li>异步：通信双方不需要共享时钟信号，而是各自有一个独立的时钟源。通信的开始和结束由起始位和停止位来标识。</li><li>数据帧结构：每个数据帧通常包括一个起始位、5到9个数据位、一个可选的奇偶校验位和一个或两个停止位。</li><li>波特率：通信速率，即每秒传输的位数。通信双方需要设置相同的波特率以进行有效通信。</li><li>UART 通信只需两个设备之间的两个数据线，适用于点对点通信。</li><li>可扩展：通过添加额外的硬件（例如 RS-232、RS-485、RS-422 等），UART通信可以用于长距离传输或多设备通信。</li></ul><h2 id="uart-通信过程">UART 通信过程</h2><ul><li>发送设备将要发送的字节（8位数据）从并行到串行转换，并将起始位、数据位、奇偶校验位（可选）和停止位组合成一个数据帧。</li><li>数据帧通过 TX 线发出，连接对面的RX引脚。</li><li>接收设备的 RX 线接收数据帧，连接对面的TX引脚。</li><li>接收设备通过内部时钟，从起始位开始，同步地对接收到的数据位进行采样。</li><li>将接收到的数据位转换回字节，并检查奇偶校验位（如果存在）以确保数据传输的正确性。</li><li>如NE果数据有效，接收设备会处理这些数据。如果检测到错误，接收设备可以请求重发。## 相关寄存器</li><li>UART_SR状态寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_SR寄存器.png" /><ul><li>TXE：置1，说明发送数据寄存器空，可以发送下一字节数据（写UART_DR会自动将TXE置0)</li><li>TC：置1，说明一帧发送完毕。</li><li>RXNE：置1，说明读数据寄存器非空，数据已经接收</li></ul></li><li>UART_DR数据寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_DR寄存器.png" /><ul><li>用于存放接收到的数据，与要发送的数据</li><li>接收数据：dat=UART2_DR</li><li>发送数据：UART2_DR=dat</li></ul></li><li>UART_BRR1、UART_BRR2波特率寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_BRR1寄存器.png" /><imgsrc="assets/STM8单片机.assets/STM8的UART_BRR2寄存器.png" /><ul><li>用于设置波特率</li><li>比如2MHz时钟下9600波特率，2 000000/9600=208=0x00d0,故BRR2=0x00（波特率的高4位与低4位）,BRR1=0x0d(波特率的中间8位)</li></ul></li><li>UART_CR1控制寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_CR1寄存器.png" /><ul><li>用来配置接收数据的位数</li><li>M字长，置0是8个数据位，置1是9个数据位</li><li>UARTD 禁用UART，置0是使能UART，置1是禁用UART</li><li>PCEN使能校验位，置0是无校验位，置1是有奇偶校验位</li></ul></li><li>UART_CR2控制寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_CR2寄存器.png" /><ul><li>用来使能UART发送和接收，使能发送和接收中断等</li><li>RIEN接收中断使能，置1可使能接收中断</li><li>TEN发送使能，允许UART发送数据</li><li>REN接收使能，允许UART接收数据</li></ul></li><li>UART_CR3控制寄存器<imgsrc="assets/STM8单片机.assets/STM8的UART_CR3寄存器.png" /><ul><li>设置停止位个数，STOP[1:0]为00、10、11分别表示1、2、1.5个停止位 ##示例代码（寄存器版本) 每接收到8字节数据，便将这8字节数据发送回去<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostm8s005k6.h&quot;</span><br><span class="line"></span><br><span class="line">#define u8 unsigned char</span><br><span class="line">#define u16 unsigned short</span><br><span class="line">#define u32 unsigned long</span><br><span class="line"></span><br><span class="line">u8 cntRxd=0;</span><br><span class="line">u8 bufRxd[10]=&#123;0&#125;;</span><br><span class="line">u8 sendFlag=0;</span><br><span class="line"></span><br><span class="line">void UART2_Config(u32 baudrate)//主时钟16 MHz</span><br><span class="line">&#123;</span><br><span class="line">u32 baud=16000000/baudrate;</span><br><span class="line">//先写BRR2 , 再写BRR1</span><br><span class="line">UART2_BRR2 = ((u8)((baud &amp; 0xf000) &gt;&gt; 8 )) | ((unsigned char)(baud &amp; 0x000f));       //先写波特比率的高4位与低4位</span><br><span class="line">UART2_BRR1 =  ((u8)((baud &amp; 0x0ff0) &gt;&gt; 4));      //后写波特比率的中间8位</span><br><span class="line"></span><br><span class="line">UART2_CR1 = 0x00; // 8位数据，无奇偶校验</span><br><span class="line">UART2_CR2 = 0x2C; // 发送使能，接收使能，接收中断使能</span><br><span class="line">UART2_CR3 = 0x00; // 1个停止位 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UartWrite(u8 *buf,u8 len)</span><br><span class="line">&#123;</span><br><span class="line">  while (len--)//循环发送所有字节</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">    UART2_DR =*buf++;//发送一个字节数据</span><br><span class="line">    while (!(UART2_SR&amp;0X40));//等待该字节发送完成</span><br><span class="line">  &#125;</span><br><span class="line">  while (!(UART2_SR&amp;0X80));//等待一帧发送完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">asm(&quot;sim&quot;);                     //关闭系统总中断</span><br><span class="line">CLK_CKDIVR = 0x00;              //CPUDIV = 1 HSIDIV = 1  内部时钟 = 16Mhz</span><br><span class="line">UART2_Config(9600);//设置波特率为9600</span><br><span class="line">asm(&quot;rim&quot;); //打开系统总中断</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">if(sendFlag==1)</span><br><span class="line">&#123;</span><br><span class="line">UartWrite(bufRxd,cntRxd);</span><br><span class="line">cntRxd=0;</span><br><span class="line">sendFlag=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma vector = 23              //设置串口2接收中断向量号 = 23</span><br><span class="line">__interrupt void UART2_RX_RXNE(void)//UART2接收中断处理函数</span><br><span class="line">&#123;    </span><br><span class="line">if((UART2_SR&amp;0X20)) </span><br><span class="line">&#123;</span><br><span class="line">                UART2_SR&amp;=~(0x20);//清除接收中断标志位</span><br><span class="line">if(cntRxd&lt;8)</span><br><span class="line">&#123;</span><br><span class="line">bufRxd[cntRxd++]=UART2_DR;</span><br><span class="line">&#125;</span><br><span class="line">                if(cntRxd==8)</span><br><span class="line">&#123;</span><br><span class="line">sendFlag=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure> ## 示例代码（库函数版本）每接收到8字节数据，便将这8字节数据发送回去 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;stm8s.h&quot;</span><br><span class="line">#include &quot;stm8s_uart2.h&quot;</span><br><span class="line"></span><br><span class="line">u8 cntRxd=0;</span><br><span class="line">u8 bufRxd[10]=&#123;0&#125;;</span><br><span class="line">u8 sendFlag=0;</span><br><span class="line"></span><br><span class="line">void UART2_Config(u32 baud)//主时钟16 MHz</span><br><span class="line">&#123;</span><br><span class="line">UART2_DeInit();//恢复默认配置</span><br><span class="line">//配置串口参数为：波特率baud，8位数据位，1位停止位，无校验，禁止同步传输，允许接收发送</span><br><span class="line">UART2_Init((u32)baud,</span><br><span class="line">           UART2_WORDLENGTH_8D,</span><br><span class="line">           UART2_STOPBITS_1,</span><br><span class="line">           UART2_PARITY_NO,</span><br><span class="line">           UART2_SYNCMODE_CLOCK_DISABLE,</span><br><span class="line">           UART2_MODE_TXRX_ENABLE);</span><br><span class="line">UART2_ITConfig(UART2_IT_RXNE_OR, ENABLE);//使能接收中断</span><br><span class="line">UART2_Cmd(ENABLE);//使能UART</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CLK_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);//HSI不分频，单片机工作在16 MHz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UartWrite(u8 *buf,u8 len)</span><br><span class="line">&#123;</span><br><span class="line">while (len--)//循环发送所有字节</span><br><span class="line">&#123;</span><br><span class="line">UART2_SendData8(*buf++);                                    //发送一个字节数据</span><br><span class="line">while(!UART2_GetFlagStatus(UART2_FLAG_TXE));//等待该字节发送完成</span><br><span class="line">&#125;</span><br><span class="line">while(!UART2_GetFlagStatus(UART2_FLAG_TC));//等待一帧发送完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">asm(&quot;sim&quot;);                     //关闭系统总中断</span><br><span class="line">CLK_Config();              //CPUDIV = 1 HSIDIV = 1  内部时钟 = 16Mhz</span><br><span class="line">UART2_Config(9600);//设置波特率为9600</span><br><span class="line">asm(&quot;rim&quot;); //打开系统总中断</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">if(sendFlag==1)</span><br><span class="line">&#123;</span><br><span class="line">UartWrite(bufRxd,cntRxd);</span><br><span class="line">cntRxd=0;</span><br><span class="line">sendFlag=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma vector = 23              //设置串口2接收中断向量号 = 23</span><br><span class="line">__interrupt void UART2_RX_RXNE(void)//UART2接收中断处理函数</span><br><span class="line">&#123;    </span><br><span class="line">if(UART2_GetITStatus(UART2_IT_RXNE) != RESET) </span><br><span class="line">&#123;</span><br><span class="line">                 UART2_ClearITPendingBit(UART2_IT_RXNE);            //清除UART1挂起标志//清除接收中断标志位</span><br><span class="line">if(cntRxd&lt;8)</span><br><span class="line">&#123;</span><br><span class="line">bufRxd[cntRxd++]=UART2_ReceiveData8();</span><br><span class="line">&#125;</span><br><span class="line">                if(cntRxd==8)</span><br><span class="line">&#123;</span><br><span class="line">sendFlag=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//程序参数纠错//别问为什么，反正不加报错</span><br><span class="line">#ifdef USE_FULL_ASSERT</span><br><span class="line">void assert_failed(u8* file, u32 line)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="ad模数转换">AD模数转换</h1><h1 id="spi">SPI</h1><h1 id="iic">IIC</h1><h2 id="iic定义">IIC定义</h2><ul><li><p>IIC总线是两线式串行总线，用于连接多个芯片和传感器。由两条信号线完成通信，是半双工通信协议：SDA——数据线、SCL——时钟线</p></li><li><p>IIC同时支持多个主机和多个从机，每个设备都有7位的唯一的地址。其中产生时钟信号的是主机，在此时，接收数据的都被认为是从机。</p></li><li><p>一般采用开漏结构和总线相连，因此SCL和SDA都需接上拉电阻。故总线空闲，SCL,SDA均为高电平，连接总线任一器件输出低电平，都会拉低总线电平。## IIC通信时序</p></li><li><p><strong>空闲状态</strong>：SCL线与SDA线均处于高电平状态，等待起始信号</p></li><li><p><strong>起始信号</strong>：由主机发送。SCL线为高电平期间，SDA线由高电平向低电平的变化表示起始信号。</p></li><li><p><strong>停止信号</strong>：由主机发送。SCL线为高电平期间，SDA线由低电平向高电平的变化表示停止信号（释放SDA时，SDA会自动被拉高）</p></li><li><p><strong>数据传输</strong>：SCL为低电平期间，才允许改变SDA电平，传输数据。SCK为高电平时，用以数据读取。故除开始结束信号外，SCL高电平时，不允许改变SDA。</p></li><li><p><strong>数据传送格式</strong>：以8位字节为单位传送，高位在前。每个字节发送完成后，通信过程中需要严格遵守IIC总线协议，包括起始信号、控制字节、地址字节、数据字节、应答信号、停止信号等。</p></li><li><p><strong>应答信号ACK：</strong></p><ul><li>当每个字节发送完成后，如果希望继续发送数据，而不是停止通信，接收方应该发送ACK表示接收到数据，请继续通信。举例说明，当主设备是发送方，向从设备写数据，从设备接收完一个字节还希望继续接收的话，会发送ACK信号，而主设备将接收到ACK。当主设备是接收方，从从设备读数据，接收完一个字节还希望继续接收的话，将发送ACK数据告诉从机。</li><li>当发送方传送完8位时，发送方释放SDA，由接收方控制SDA，且SDA=0；</li></ul></li><li><p><strong>应答信号NACK：</strong></p><ul><li>当每个字节发送完成后，如果不希望继续发送数据，停止通信，接收方将发送NACK表示停止通信。</li><li>当发送方传送完8位时，发送方释放SDA，由接收方控制SDA，且SDA=1。</li></ul></li><li><p><strong>地址字节：</strong> 由7位设备地址，加一位R/<spanclass="math inline">\(\overline{W}\)</span>构成。R/<spanclass="math inline">\(\overline{W}\)</span>为1表示接下来是主机读信号，从机发送信号，为0表示接下来是主机发送，从机读取。（上面有一横，表示低电平有效）## 示例代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#define SCL_PORT GPIOx</span><br><span class="line">#define SCL_PIN GPIO_PIN_x</span><br><span class="line"></span><br><span class="line">#define SDA_PORT GPIOx</span><br><span class="line">#define SDA_PIN GPIO_PIN_x</span><br><span class="line"></span><br><span class="line">#define SCL_H              GPIO_WriteHigh(SCL_PORT, SCL_PIN)</span><br><span class="line">#define SCL_L              GPIO_WriteLow(SCL_PORT, SCL_PIN)</span><br><span class="line">#define SDA_H              GPIO_WriteHigh(SDA_PORT, SDA_PIN)</span><br><span class="line">#define SDA_L              GPIO_WriteLow(SDA_PORT, SDA_PIN)</span><br><span class="line"></span><br><span class="line">#define SDAM             GPIO_ReadInputPin(SDA_PORT, SDA_PIN)</span><br><span class="line">#define SET_SCL_OUT()    &#123;GPIO_Init(SCL_PORT, SCL_PIN, GPIO_MODE_OUT_PP_HIGH_SLOW);&#125;</span><br><span class="line">#define SET_SDA_OUT()    &#123;GPIO_Init(SDA_PORT, SDA_PIN, GPIO_MODE_OUT_PP_HIGH_SLOW);&#125;</span><br><span class="line">#define SET_SDA_IN()     &#123;GPIO_Init(SDA_PORT, SDA_PIN, GPIO_MODE_IN_FL_NO_IT);&#125;</span><br><span class="line">#define IIC_TIME()       delayus(5)</span><br><span class="line"></span><br><span class="line">void IIC_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">    //将两个数据线都设置为输出模式,起始高电平</span><br><span class="line">    SET_SCL_OUT();</span><br><span class="line">    SET_SDA_OUT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IIC_Start(void)//SCL线为高电平期间，SDA线由高电平向低电平</span><br><span class="line">&#123;</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">SCL_H;</span><br><span class="line">SDA_H;</span><br><span class="line">IIC_TIME();//等待电平稳定</span><br><span class="line">SDA_L;//拉低SDA电平，发送开始信号</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_L;//拉低SCL电平，等待数据传输</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IIC_Stop(void)//SCL为高电平期间，SDA由低电平到高电平</span><br><span class="line">&#123;</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">SDA_L;//电平置低</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_H;//数据读取</span><br><span class="line">IIC_TIME();</span><br><span class="line">SDA_H;//电平置高</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IIC_SetACK(void)&#123;  //发送ACK信号</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">SDA_L;//发送ACK</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_H;//数据读取</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_L;//便于下次操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IIC_SendNACK(void)&#123;//发送NACK信号</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">SDA_H;//发送ACK</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_H;//数据读取</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_L;//便于下次操作   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 IIC_RecvACK(void)</span><br><span class="line">&#123;</span><br><span class="line">u8 recvAck;</span><br><span class="line">SET_SDA_IN();</span><br><span class="line">SCL_H;//准备读取SDA</span><br><span class="line">IIC_TIME();</span><br><span class="line">recvAck=(u8)SDAM;//读取SDA数据</span><br><span class="line">IIC_TIME();</span><br><span class="line">    //占用SDA，由于接上拉电阻，默认输出高电平，此时SCL为高电平，可能会出现误发结束信号</span><br><span class="line">    //因此先置低SCL，然后占用SDA</span><br><span class="line">SCL_L;</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">return recvAck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 IIC_ReadByte(void)&#123;//读取一个字节数据</span><br><span class="line">u8 i,dat=0;</span><br><span class="line">SET_SDA_IN();</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">SCL_H;//数据读取，此处可判断SCL是否空闲，进行时钟同步</span><br><span class="line">dat&lt;&lt;=1;</span><br><span class="line">if(SDAM)</span><br><span class="line">&#123;</span><br><span class="line">dat|=0x01;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">dat&amp;= 0xfe;</span><br><span class="line">&#125;</span><br><span class="line">IIC_TIME();</span><br><span class="line">SCL_L;//恢复SCL为低电平</span><br><span class="line">IIC_TIME();</span><br><span class="line">&#125;</span><br><span class="line">SET_SDA_OUT();</span><br><span class="line">return dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 IIC_WriteByte(u8 dat)&#123;//发送一个字节数据</span><br><span class="line"></span><br><span class="line">    u8 i;</span><br><span class="line">    SET_SDA_OUT();//获取SDA</span><br><span class="line">    for(i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    SCL_L;</span><br><span class="line">    IIC_TIME();</span><br><span class="line">        if(dat&amp;0x80)&#123;//传输的数据是高位在前</span><br><span class="line">            SDA_H;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            SDA_L;;</span><br><span class="line">        &#125;</span><br><span class="line">        dat&lt;&lt;=1; </span><br><span class="line">        SCL_H;</span><br><span class="line">        IIC_TIME();    </span><br><span class="line">    &#125;</span><br><span class="line">    SCL_L;</span><br><span class="line">    IIC_TIME();</span><br><span class="line">    return IIC_RecvACK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> # EEPROM</p></li></ul><h1 id="其他">其他</h1><h4 id="芯片引脚"><strong>芯片引脚</strong></h4><h5id="数据手册的芯片引脚和现实的芯片引脚如何对应">数据手册的芯片引脚和现实的芯片引脚如何对应</h5><p>可以看出，现实的芯片有一个小的圆形印记，将芯片的字体摆正，圆形印记在左下方，所以芯片的引脚是以左下方的第一个引脚为1号，逆时针编号到第n号(比如64)</p><figure><img src="assets/STM8单片机.assets/引脚对照图.png" alt="引脚对照图" /><figcaption aria-hidden="true">引脚对照图</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资源&quot;&gt;参考资源&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/4.html"/>
    <id>http://example.com/blog/4.html</id>
    <published>2024-01-05T03:12:45.288Z</published>
    <updated>2024-02-22T05:33:21.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="icpispiap三种烧录方式">ICP/ISP/IAP三种烧录方式</h1><p>比如STM32支持SWD接口烧录，STM8支持STIM接口烧录，51芯片支持串口烧录。常见的CPU/MCU支持的烧录方式主要有以下三种： - <strong>ICP(In CircuitPrograming)</strong> -也叫在电路编程，通过芯片的调试端口烧录代码。比如SWD,JATG,SWIM接口。什么芯片支持什么样的调试接口烧录是在芯片出厂就确定的，无可更改。比如STM32，新塘芯片是SWD烧录，STM8是JATG烧录，等等。一般通过对应厂商的软件(如KEIL，IAR)和仿真器(如ST-Link)来烧录的都是此类烧录方式。- <strong>ISP(In System Programing)</strong> -也叫在系统编程，是芯片通过USB/UART/SPI/IIC等接口的引导代码(芯片厂商内置)去更新芯片的程序的一种烧录方式。STM32,51芯片都支持UART串口的ISP烧录(51的STC-ISP软件烧录就是一种ISP烧录方法)- <strong>IAP(In applicating Programing)</strong> -也叫在应用编程，是通过芯片通过其内的代码实现对芯片内代码的在线电擦除和编程的方法，是开发者自己编写代码实现的。# JATG/SWIM/SWD三种烧录接口 - <strong>JATG</strong> -四线:TDI数据输入、TMS模式选择、TCK时钟、TDO数据输出 -<strong>SWD</strong> - 二线：DIO数据输入输出，CLK时钟线 - SWIM -一线：SWIM数据输入输出实际上一般烧录接口并不只这几根线，这只是必备的几根线。比如实际中，SWIM通常是四线:VCC电源、SWIM数据、RESET复位，GND接地。比如SWD四线:VCC电源、DIO数据、CLK时钟，GND接地。看正电原子的ST-LINK甚至可以发现SWD有20个引脚。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;icpispiap三种烧录方式&quot;&gt;ICP/ISP/IAP三种烧录方式&lt;/h1&gt;
&lt;p&gt;比如STM32支持SWD接口烧录，STM8支持STIM接口烧录，51芯片支持串口烧录。
常见的CPU/MCU支持的烧录方式主要有以下三种： - &lt;strong&gt;ICP(In </summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/20.html"/>
    <id>http://example.com/blog/20.html</id>
    <published>2024-01-05T01:49:10.382Z</published>
    <updated>2024-02-22T05:33:21.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gpio">GPIO</h1><h1 id="adc">ADC</h1><h1 id="eeprom">EEPROM</h1><h1 id="定时器">定时器</h1><h1 id="uart通信">UART通信</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//初始化串口，使用。需要的话，初始化输入输出，修改串口函数。</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;STC8G_H_UART.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/***************  串口初始化函数 *****************/</span><br><span class="line">voidUART_config(void)</span><br><span class="line">&#123;</span><br><span class="line">COMx_InitDefineCOMx_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;//模式,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span><br><span class="line">//COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//选择波特率发生器, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2, 所以不用选择)</span><br><span class="line">COMx_InitStructure.UART_BaudRate  = 115200ul;//波特率,     110 ~ 115200</span><br><span class="line">COMx_InitStructure.UART_RxEnable  = ENABLE;//接收允许,   ENABLE或DISABLE</span><br><span class="line">UART_Configuration(UART2, &amp;COMx_InitStructure);//初始化串口2 USART1,USART2,USART3,USART4</span><br><span class="line">//NVIC_UART2_Init(ENABLE,Priority_1);//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span><br><span class="line">//UART2_SW(UART2_SW_P46_P47);//UART2_SW_P10_P11,UART2_SW_P46_P47</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********************************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">u8i;</span><br><span class="line">u16j;</span><br><span class="line">UART_config();</span><br><span class="line">//如果使用RS485通信，只需将对应485芯片使能端使能，发送端使能是发送，接收端使能是接收，其余和uart通信无区别</span><br><span class="line">//举例：这里是用的stm8中的部分代码举例</span><br><span class="line">//#define   RS485_TxMode()          PD_ODR_bit.ODR7 = 1  </span><br><span class="line">//#define   RS485_RxMode()          PD_ODR_bit.ODR7 = 0</span><br><span class="line">//一般485芯片发送接收端接在一起的，一个是高电平使能，一个是低电平使能，所以485使能是这样的。</span><br><span class="line">//也见过一种接法，接收端与485芯片的RO相连，发送端与RI相连，并且发送端通过上拉电阻与三极管与使能端连在一起，这样就不必使能</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">TX2_write2buff(RX1_Buffer[0]);//将接收的数据发送回去</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">TX2_write2buff，是将放入发送缓冲区</span><br><span class="line"></span><br><span class="line">这是库函数中串口的发送部分,放入缓冲区后，用串口中断函数接收，发送。只摘取了关键部分代码</span><br><span class="line">void TX2_write2buff(u8 dat)//串口2发送函数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UART2_int (void) interrupt UART2_VECTOR</span><br><span class="line">&#123;</span><br><span class="line">if(RI2)</span><br><span class="line">&#123;</span><br><span class="line">RI2 = 0;</span><br><span class="line">RX2_Buffer[COM2.RX_Cnt++] = S2BUF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(TI2)</span><br><span class="line">&#123;</span><br><span class="line">TI2 = 0;</span><br><span class="line">S2BUF = TX2_Buffer[COM2.TX_read];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h1 id="看门狗">看门狗</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;STC8G_H_WDT.h&quot;</span><br><span class="line"></span><br><span class="line">voidWDT_config(void)</span><br><span class="line">&#123;</span><br><span class="line">WDT_InitTypeDefWDT_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">WDT_InitStructure.WDT_Enable     = ENABLE;//中断使能   ENABLE或DISABLE</span><br><span class="line">WDT_InitStructure.WDT_IDLE_Mode  = WDT_IDLE_STOP;//IDLE模式是否停止计数WDT_IDLE_STOP,WDT_IDLE_RUN</span><br><span class="line">WDT_InitStructure.WDT_PS         = WDT_SCALE_16;//看门狗定时器时钟分频系数WDT_SCALE_2,WDT_SCALE_4,WDT_SCALE_8,WDT_SCALE_16,WDT_SCALE_32,WDT_SCALE_64,WDT_SCALE_128,WDT_SCALE_256</span><br><span class="line">WDT_Inilize(&amp;WDT_InitStructure);//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">//代码启动</span><br><span class="line"></span><br><span class="line">WDT_config();</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">WDT_Clear();   //喂狗。给定时间内（由时钟频率和分频系数决定)不喂狗, 将复位,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gpio&quot;&gt;GPIO&lt;/h1&gt;
&lt;h1 id=&quot;adc&quot;&gt;ADC&lt;/h1&gt;
&lt;h1 id=&quot;eeprom&quot;&gt;EEPROM&lt;/h1&gt;
&lt;h1 id=&quot;定时器&quot;&gt;定时器&lt;/h1&gt;
&lt;h1 id=&quot;uart通信&quot;&gt;UART通信&lt;/h1&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/24.html"/>
    <id>http://example.com/blog/24.html</id>
    <published>2024-01-03T07:47:07.876Z</published>
    <updated>2024-02-22T05:33:21.205Z</updated>
    
    <content type="html"><![CDATA[<p>从数据手册可看出： - 发送时低位在前 -总共有三种指令：数据命令指令、显示控制指令、地址指令 -指令和显示数据的区分：STB下降沿第一个字节是指令，其余是数据 -DIO、CLK是数据线和时钟线，STB是发送控制线</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从数据手册可看出： - 发送时低位在前 -
总共有三种指令：数据命令指令、显示控制指令、地址指令 -
指令和显示数据的区分：STB下降沿第一个字节是指令，其余是数据 -
DIO、CLK是数据线和时钟线，STB是发送控制线&lt;/p&gt;
</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/0.html"/>
    <id>http://example.com/blog/0.html</id>
    <published>2024-01-02T08:49:04.400Z</published>
    <updated>2024-02-22T05:33:21.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_21805743/article/details/120560226(转载自它，留个备份)</span><br><span class="line">https://www.cnblogs.com/NickShen86/p/12809518.html</span><br></pre></td></tr></table></figure><h1 id="modbus-rtu协议">Modbus-RTU协议</h1><h3id="一功能码0x03读保持寄存器可读多个或者单个寄存器内容">一、功能码0x03：读保持寄存器，可读多个或者单个寄存器内容</h3><p><strong>主机请求</strong></p><table><colgroup><col style="width: 18%" /><col style="width: 12%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>可输入的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>根据从机地址而定</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x03</td></tr><tr class="odd"><td>寄存器起始地址</td><td>2个字节</td><td>根据所要读取的寄存器位置而定，范围是0x0000 至 0xFFFF</td></tr><tr class="even"><td>寄存器数目</td><td>2个字节</td><td>1 至 125（0x7D)</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><p><strong>从机响应</strong></p><table><colgroup><col style="width: 13%" /><col style="width: 13%" /><col style="width: 72%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>从机地址</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x03</td></tr><tr class="odd"><td>字节数</td><td>1个字节</td><td>2×N</td></tr><tr class="even"><td>寄存器的值</td><td>N×2 个字节</td><td>根据所读取的保持寄存器内容而定</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来(先发低字节，后发高字节)</td></tr></tbody></table><p><strong>其中N ＝ 寄存器的数量</strong><strong>从机返回错误帧</strong></p><table><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>从机地址</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x83</td></tr><tr class="odd"><td>异常码</td><td>1个字节</td><td>01 或 02 或 03 或 04</td></tr><tr class="even"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><h3 id="二功能码-0x06写单个保持寄存器">二、功能码0x06：写单个保持寄存器</h3><p>写单个保持寄存器的返回帧和写入帧是一模一样‘</p><p><strong>主机请求</strong></p><table><colgroup><col style="width: 13%" /><col style="width: 13%" /><col style="width: 72%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>可输入的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>根据从机地址而定</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x06</td></tr><tr class="odd"><td>寄存器地址</td><td>2个字节</td><td>根据所要写入的寄存器位置而定，范围是0x0000 至 0xFFFF</td></tr><tr class="even"><td>寄存器值</td><td>2个字节</td><td>0x0000 至 0xFFFF</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><p><strong>从机响应</strong></p><table><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 70%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>根据从机地址而定</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x06</td></tr><tr class="odd"><td>寄存器地址</td><td>2个字节</td><td>根据从机被读取的地址而定，范围是0x0000 至 0xFFFF</td></tr><tr class="even"><td>寄存器值</td><td>2个字节</td><td>根据从机所存放的数据而定，范围是0x0000 至 0xFFFF</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><p><strong>错误</strong></p><table><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>从机地址</td></tr><tr class="even"><td>差错码</td><td>1个字节</td><td>0x86</td></tr><tr class="odd"><td>异常码</td><td>1个字节</td><td>01 或 02 或 03 或 04</td></tr><tr class="even"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><h3 id="三功能码-0x10写多个保持寄存器">三、功能码0x10：写多个保持寄存器</h3><p><strong>主机请求</strong></p><table><colgroup><col style="width: 27%" /><col style="width: 11%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>可输入的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>根据从机地址而定</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x10</td></tr><tr class="odd"><td>寄存器起始地址</td><td>2个字节</td><td>根据所要写入的寄存器位置而定，范围是0x0000 至 0xFFFF</td></tr><tr class="even"><td>寄存器数目</td><td>2个字节</td><td>根据所要写入的寄存器数目而定，范围是0x0001 至 0x0078</td></tr><tr class="odd"><td>字节数</td><td>1个字节</td><td>2×N</td></tr><tr class="even"><td>寄存器值</td><td>N×2 个字节</td><td>要写入的数据值</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><p><strong>其中，N为寄存器的数量</strong></p><p><strong>从机响应</strong></p><table><colgroup><col style="width: 18%" /><col style="width: 13%" /><col style="width: 67%" /></colgroup><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>根据从机地址而定</td></tr><tr class="even"><td>功能码</td><td>1个字节</td><td>0x10</td></tr><tr class="odd"><td>寄存器起始地址</td><td>2个字节</td><td>根据被写入的寄存器地址而定，范围是0x0000 至 0xFFFF</td></tr><tr class="even"><td>寄存器数目</td><td>2个字节</td><td>1 至 123（0x7B）</td></tr><tr class="odd"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table><p><strong>错误</strong></p><table><thead><tr class="header"><th>域名</th><th>所占字节数</th><th>返回的数据内容</th></tr></thead><tbody><tr class="odd"><td>从机地址</td><td>1个字节</td><td>从机地址</td></tr><tr class="even"><td>差错码</td><td>1个字节</td><td>0x90</td></tr><tr class="odd"><td>异常码</td><td>1个字节</td><td>01 或 02 或 03 或 04</td></tr><tr class="even"><td>CRC校验码</td><td>2个字节</td><td>根据前面的数据计算出来</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/21.html"/>
    <id>http://example.com/blog/21.html</id>
    <published>2023-12-22T02:09:09.978Z</published>
    <updated>2024-02-22T05:33:21.203Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/25.html"/>
    <id>http://example.com/blog/25.html</id>
    <published>2023-12-22T02:08:40.950Z</published>
    <updated>2024-02-22T05:33:21.206Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/17.html"/>
    <id>http://example.com/blog/17.html</id>
    <published>2023-12-22T02:05:02.819Z</published>
    <updated>2024-02-22T05:33:21.201Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考例程包：https://www.stcaimcu.com/forum.php?mod=viewthread&amp;tid=1525</span><br></pre></td></tr></table></figure><h1 id="adc">ADC</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//代码来自STC8H8K64U为主控芯片的实验箱8</span><br><span class="line">//ADC需做操作：AD口设置为输入口，浮空输入。配置初始化。使用ADC</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;STC8G_H_ADC.h&quot;</span><br><span class="line">#include&quot;STC8G_H_GPIO.h&quot;</span><br><span class="line">voidGPIO_config(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDefGPIO_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin  = GPIO_Pin_0 ;//指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7</span><br><span class="line">GPIO_InitStructure.Mode = GPIO_HighZ;//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span><br><span class="line">GPIO_Inilize(GPIO_P0,&amp;GPIO_InitStructure);//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************* AD配置函数 *******************/</span><br><span class="line">voidADC_config(void)</span><br><span class="line">&#123;</span><br><span class="line">ADC_InitTypeDefADC_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">ADC_InitStructure.ADC_SMPduty   = 31;//ADC 模拟信号采样时间控制, 0~31（注意： SMPDUTY 一定不能设置小于 10）</span><br><span class="line">ADC_InitStructure.ADC_CsSetup   = 0;//ADC 通道选择时间控制 0(默认),1</span><br><span class="line">ADC_InitStructure.ADC_CsHold    = 1;//ADC 通道选择保持时间控制 0,1(默认),2,3</span><br><span class="line">ADC_InitStructure.ADC_Speed     = ADC_SPEED_2X16T;//设置 ADC 工作时钟频率ADC_SPEED_2X1T~ADC_SPEED_2X16T</span><br><span class="line">ADC_InitStructure.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;//ADC结果调整,ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIFIED</span><br><span class="line">ADC_Inilize(&amp;ADC_InitStructure);//初始化</span><br><span class="line">ADC_PowerControl(ENABLE);//ADC电源开关, ENABLE或DISABLE</span><br><span class="line">//NVIC_ADC_Init(DISABLE,Priority_0);//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_config();</span><br><span class="line">ADC_config();</span><br><span class="line">EA = 1;//开中断</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">Get_ADCResult(8);//ADC有0-15这16个通道，这里读取的是P0.0对应的ADC8的AD值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="eeprom">EEPROM</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//调用库函数就可以了，没有别的</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include &quot;STC8G_H_EEPROM.h&quot;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">u8 dat[10]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">EEPROM_read_n(0,dat,10);//将10个字节数据从首地址为0的EEPROM读出</span><br><span class="line">EEPROM_SectorErase(0);//擦除地址0对应的一个扇区（512字节）</span><br><span class="line">EEPROM_write_n(0,dat,10);//将10个字节数据写入首地址为0的EEPROM</span><br><span class="line">//还是改一下，擦除扇区和读写字节不协调。</span><br><span class="line">EA = 1;//开中断</span><br><span class="line">while (1);</span><br><span class="line">&#125;</span><br><span class="line">void EEPROM_ReadPage(u8 *dat,u8 addr,u8 len)</span><br><span class="line">&#123;</span><br><span class="line">EEPROM_read_n(addr,dat,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EEPROM_ErasePage(u8 addr)</span><br><span class="line">&#123;</span><br><span class="line">EEPROM_SectorErase(addr);</span><br><span class="line">&#125;</span><br><span class="line">void EEPROM_WritePage(u8 *dat,u8 addr,u8 len)</span><br><span class="line">&#123;</span><br><span class="line">EEPROM_write_n(addr,dat,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gpio">GPIO</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//初始化输入输出</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;STC8G_H_GPIO.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidGPIO_config(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDefGPIO_InitStructure;//结构定义</span><br><span class="line">GPIO_InitStructure.Pin  = GPIO_Pin_0;//指定要初始化的IO,</span><br><span class="line">GPIO_InitStructure.Mode = GPIO_PullUp;//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span><br><span class="line">GPIO_Inilize(GPIO_P4,&amp;GPIO_InitStructure);//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************** 主函数 **************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_config();</span><br><span class="line">P40 = 0;//小灯灭</span><br><span class="line">P40 = 1;//小灯亮</span><br><span class="line">EA = 1;//开中断</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="定时器">定时器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//初始化定时器，按需要修改定时器中断函数</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;STC8G_H_Timer.h&quot;</span><br><span class="line"></span><br><span class="line">voidTimer_config(void)</span><br><span class="line">&#123;</span><br><span class="line">TIM_InitTypeDefTIM_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">//定时器0做16位自动重装, 中断频率为100000HZ，中断函数从P6.7取反输出50KHZ方波信号.</span><br><span class="line">TIM_InitStructure.TIM_Mode      = TIM_16BitAutoReload;//指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,TIM_8BitAutoReload,TIM_16BitAutoReloadNoMask</span><br><span class="line">TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;//指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext</span><br><span class="line">TIM_InitStructure.TIM_ClkOut    = DISABLE;//是否输出高速脉冲, ENABLE或DISABLE</span><br><span class="line">TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / 100000UL);//初值,</span><br><span class="line">TIM_InitStructure.TIM_Run       = ENABLE;//是否初始化后启动定时器, ENABLE或DISABLE</span><br><span class="line">Timer_Inilize(Timer0,&amp;TIM_InitStructure);//初始化Timer0  Timer0,Timer1,Timer2,Timer3,Timer4</span><br><span class="line">//NVIC_Timer0_Init(ENABLE,Priority_0);//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">Timer_config();</span><br><span class="line">while (1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void timer0_int (void) interrupt TIMER0_VECTOR //中断处理函数</span><br><span class="line">&#123;</span><br><span class="line">//省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="uart通信">UART通信</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//初始化串口，使用。需要的话，初始化输入输出，修改串口函数。</span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;STC8G_H_UART.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/***************  串口初始化函数 *****************/</span><br><span class="line">voidUART_config(void)</span><br><span class="line">&#123;</span><br><span class="line">COMx_InitDefineCOMx_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;//模式,   UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span><br><span class="line">//COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//选择波特率发生器, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2, 所以不用选择)</span><br><span class="line">COMx_InitStructure.UART_BaudRate  = 115200ul;//波特率,     110 ~ 115200</span><br><span class="line">COMx_InitStructure.UART_RxEnable  = ENABLE;//接收允许,   ENABLE或DISABLE</span><br><span class="line">UART_Configuration(UART2, &amp;COMx_InitStructure);//初始化串口2 USART1,USART2,USART3,USART4</span><br><span class="line">//NVIC_UART2_Init(ENABLE,Priority_1);//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span><br><span class="line">//UART2_SW(UART2_SW_P46_P47);//UART2_SW_P10_P11,UART2_SW_P46_P47</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********************************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">u8i;</span><br><span class="line">u16j;</span><br><span class="line">UART_config();</span><br><span class="line">//如果使用RS485通信，只需将对应485芯片使能端使能，发送端使能是发送，接收端使能是接收，其余和uart通信无区别</span><br><span class="line">//举例：这里是用的stm8中的部分代码举例</span><br><span class="line">//#define   RS485_TxMode()          PD_ODR_bit.ODR7 = 1  </span><br><span class="line">//#define   RS485_RxMode()          PD_ODR_bit.ODR7 = 0</span><br><span class="line">//一般485芯片发送接收端接在一起的，一个是高电平使能，一个是低电平使能，所以485使能是这样的。</span><br><span class="line">//也见过一种接法，接收端与485芯片的RO相连，发送端与RI相连，并且发送端通过上拉电阻与三极管与使能端连在一起，这样就不必使能</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">TX2_write2buff(RX1_Buffer[0]);//将接收的数据发送回去</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">TX2_write2buff，是将放入发送缓冲区</span><br><span class="line"></span><br><span class="line">这是库函数中串口的发送部分,放入缓冲区后，用串口中断函数接收，发送。只摘取了关键部分代码</span><br><span class="line">void TX2_write2buff(u8 dat)//串口2发送函数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UART2_int (void) interrupt UART2_VECTOR</span><br><span class="line">&#123;</span><br><span class="line">if(RI2)</span><br><span class="line">&#123;</span><br><span class="line">RI2 = 0;</span><br><span class="line">RX2_Buffer[COM2.RX_Cnt++] = S2BUF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(TI2)</span><br><span class="line">&#123;</span><br><span class="line">TI2 = 0;</span><br><span class="line">S2BUF = TX2_Buffer[COM2.TX_read];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h1 id="看门狗">看门狗</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;STC8G_H_WDT.h&quot;</span><br><span class="line"></span><br><span class="line">voidWDT_config(void)</span><br><span class="line">&#123;</span><br><span class="line">WDT_InitTypeDefWDT_InitStructure;//结构定义</span><br><span class="line"></span><br><span class="line">WDT_InitStructure.WDT_Enable     = ENABLE;//中断使能   ENABLE或DISABLE</span><br><span class="line">WDT_InitStructure.WDT_IDLE_Mode  = WDT_IDLE_STOP;//IDLE模式是否停止计数WDT_IDLE_STOP,WDT_IDLE_RUN</span><br><span class="line">WDT_InitStructure.WDT_PS         = WDT_SCALE_16;//看门狗定时器时钟分频系数WDT_SCALE_2,WDT_SCALE_4,WDT_SCALE_8,WDT_SCALE_16,WDT_SCALE_32,WDT_SCALE_64,WDT_SCALE_128,WDT_SCALE_256</span><br><span class="line">WDT_Inilize(&amp;WDT_InitStructure);//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">//代码启动</span><br><span class="line"></span><br><span class="line">WDT_config();</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">WDT_Clear();   //喂狗。给定时间内（由时钟频率和分频系数决定)不喂狗, 将复位,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/2.html"/>
    <id>http://example.com/blog/2.html</id>
    <published>2023-12-22T01:40:13.515Z</published>
    <updated>2024-02-22T05:33:21.190Z</updated>
    
    <content type="html"><![CDATA[<p>在学习时，我知道有各类发光二极管： <imgsrc="assets/关于各类面板的灯以及液晶显示屏.assets/发光二极管.png" />有LED点阵显示屏： **<imgsrc="assets/关于各类面板的灯以及液晶显示屏.assets/LED点阵显示屏.png" /></p><p>有点阵型液晶显示屏： <imgsrc="assets/关于各类面板的灯以及液晶显示屏.assets/1602点阵型字符液晶显示屏.png" />有笔段式液晶显示屏 <imgsrc="assets/关于各类面板的灯以及液晶显示屏.assets/笔段式液晶屏.png" /></p><p>在工作时，我见过许多开关面板和温控器面板，为了方便和成本考虑，基本上是通过多个LED灯配合透光片，实现出笔段式液晶显示屏的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习时，我知道有各类发光二极管： &lt;img
src=&quot;assets/关于各类面板的灯以及液晶显示屏.assets/发光二极管.png&quot; /&gt;
有LED点阵显示屏： **&lt;img
src=&quot;assets/关于各类面板的灯以及液晶显示屏.assets/LED点阵显示屏.</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/16.html"/>
    <id>http://example.com/blog/16.html</id>
    <published>2023-12-20T07:38:06.075Z</published>
    <updated>2024-02-22T05:33:21.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用途">用途</h1><p>用于差错检验，检查收到的数据是否误码 # 基本思想 -收发双方基于事先约定的生成多项式G(x)。 -发送方通过G(x)对待发送数据进行处理，得到差错校验码。 -接受方在接收到数据后通过G(x)对接收数据进行处理，从而判断发送过程是否产生误码。-其本质是选取合适除数，要进行校验的数据是被除数，然后做模2除法，得到的余数就是CRC校验值。</p><h1 id="手工计算">手工计算</h1><h2 id="手工计算-1">手工计算</h2><p><imgsrc="嵌入式/温控器代码阅读笔记/assets/CRC校验.assets/image-20231220163606439.png" /></p><p><imgsrc="嵌入式/温控器代码阅读笔记/assets/CRC校验.assets/image-20231220163652748.png" /><imgsrc="嵌入式/温控器代码阅读笔记/assets/CRC校验.assets/image-20231220163959925.png" /></p><p><imgsrc="嵌入式/温控器代码阅读笔记/assets/CRC校验.assets/image-20231220163929443.png" /></p><p>**</p><h2 id="举例说明">举例说明</h2><h1 id="编程实现">编程实现</h1><h2 id="思路">思路</h2><h2 id="代码">代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">u16 Caculate_CRC16(u8 *DAT,u8 len)//crc校验</span><br><span class="line">&#123;</span><br><span class="line">u16 CRC = 0xFFFF;</span><br><span class="line">u8 i,j;</span><br><span class="line">for(i=0;i&lt;len;i++)</span><br><span class="line">  &#123;</span><br><span class="line">CRC = CRC^DAT[i];</span><br><span class="line">for(j=0;j&lt;8;j++)</span><br><span class="line">  &#123;</span><br><span class="line">if(CRC&amp;0x01)</span><br><span class="line">  &#123;</span><br><span class="line">CRC = CRC&gt;&gt;1;</span><br><span class="line">CRC = CRC^0xA001;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">  &#123;</span><br><span class="line">CRC = CRC&gt;&gt;1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return CRC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在MODBUS_RTU中，如果计算结果是7F38，发送时是发送0x38,0x7F</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>背景： 应用：检错能力√ 流程图： 联系：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用途&quot;&gt;用途&lt;/h1&gt;
&lt;p&gt;用于差错检验，检查收到的数据是否误码 # 基本思想 -
收发双方基于事先约定的生成多项式G(x)。 -
发送方通过G(x)对待发送数据进行处理，得到差错校验码。 -
接受方在接收到数据后通过G(x)对接收数据进行处理，从而判断</summary>
      
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="温控器代码阅读笔记" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B8%A9%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《今日简史》</title>
    <link href="http://example.com/blog/32723.html"/>
    <id>http://example.com/blog/32723.html</id>
    <published>2023-12-13T09:07:21.000Z</published>
    <updated>2023-12-14T09:37:56.996Z</updated>
    
    <content type="html"><![CDATA[<pre><code> 信息会成为经济体系中最重要的资产，成为一种可交付的商品（这一点我是信的，对于加密货币成为通用货币，且看看吧）。</code></pre><p>正如电力带来农业社会到工业社会的巨变一样，迅速发展的人工智能与生物科技将改变世界。在许多科幻小说中都对未来社会有所畅想，过剩的生产力会带来怎样的意识形态，这是一个相当有趣的问题</p><p>我很好奇，目前的人普遍的认为，人工智能会带来生产力的过剩，有没有可能会在这一点大出意料。</p><p>确实，相比人类大脑的封闭性，计算机是可以轻易协同工作的，如果以前文作者所言，人因善讲故事协同合作而胜于其他，单以这一点评判，人类与计算机的较量，此局败。</p><p>如果人工智能会夺走人的工作，准确来说不只是工作，一个人生存于这个世界上需要与被需要的关系，自身的成就感，如果不需要人类协助人工智能都能做的比人好，人类自身存在的必要性，如何确认自身的意义，这是值得考虑的问题。</p><p>关于自由，人的感观，情绪都是可控制的，在人工智能在大数据的时代，这些都是可操控的，像是人类利用灯光，信息素控制鸟类昆虫的繁衍迁徙一样。（感觉作者的描绘与我看过的诸多科幻小说内容一致，熟悉的不是很想继续看下去，小说好歹是在讲故事）</p><p>巴基斯坦的惨状和以色列的非人行为早在2018年就为部分美国人熟知了吗，以色列政府确实不是个玩意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt; 信息会成为经济体系中最重要的资产，成为一种可交付的商品（这一点我是信的，对于加密货币成为通用货币，且看看吧）。&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如电力带来农业社会到工业社会的巨变一样，迅速发展的人工智能与生物科技将改变世界。在许多科幻小说中都对未来社会</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数字电路</title>
    <link href="http://example.com/blog/11533.html"/>
    <id>http://example.com/blog/11533.html</id>
    <published>2023-12-12T06:54:26.000Z</published>
    <updated>2023-12-13T06:47:08.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>学习教材 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清华数字电路基础</span><br><span class="line">B站王红数字电路视频：https://www.bilibili.com/video/BV18p411Z7ce/</span><br></pre></td></tr></table></figure></p><h1 id="逻辑代数基础">逻辑代数基础</h1><h2 id="逻辑电路符号及基本公式">逻辑电路符号及基本公式</h2><h4 id="下面是各种逻辑电路的符号">下面是各种逻辑电路的符号</h4><p><img src="assets/数字电路.assets/逻辑电路符号.png" /></p><h4 id="逻辑代数基本公式">逻辑代数基本公式</h4><p>和集合的交并公式差不多</p><figure><img src="assets/数字电路.assets/逻辑代数基本公式.png"alt="image-20231208101106534" /><figcaption aria-hidden="true">image-20231208101106534</figcaption></figure><p><strong>逻辑代数常用公式</strong></p><figure><img src="assets/数字电路.assets/逻辑代数常用公式.png"alt="image-20231208101145773" /><figcaption aria-hidden="true">image-20231208101145773</figcaption></figure><h4 id="代入定理反演定理和对偶定理">代入定理、反演定理和对偶定理</h4><p>和方程的代入公式以及命题取非一个道理</p><p><strong>代入定理：</strong>在任何一个包含变量A的逻辑等式中,若以另外一个逻辑式代入式中所有A的位置,则等式仍然成立。这就是所谓的代人定理。</p><blockquote><p>举例说明：若(A+B)'=A' $$B',可以将任何一个逻辑式子如(A+B)代入A，等式依然成立。((A+B)+B)'=(A+B)'$$B'</p></blockquote><p><strong>反演定理：</strong>对于任意一个逻辑式Y,若将其中所有的“·"换成“+”,“+"换成“·”,0换成1,1换成0,原变量换成反变量,反变量换成原变量,则得到的结果就是Y'。这个规律称为反演定理。</p><blockquote><p>举例说明：已知Y=AB+C+1，易得Y'=(A'+B')$<spanclass="math inline">\(C\)</span>$1</p></blockquote><p><strong>对偶定理：</strong>若两个逻辑式相等，其对偶式也相等。（对任何一个逻辑式Y，Y与Y‘互为对偶式。）</p><h2 id="逻辑函数的标准形式及化简">逻辑函数的标准形式及化简</h2><h3 id="标准形式">标准形式</h3><p>逻辑函数的标准形式是写为最小项之和或最大项之积，任何一个逻辑函数都可以这么写。比如两变量的AB+AB'，与(A+B)(A'+B)，和概率论很像对吧。</p><p>三变量最小项和最大项如图，A’与A分别记作0与1，所以AB'C写作二进制101，值是5</p><figure><img src="assets/数字电路.assets/三变量最小项编号表.png"alt="image-20231208114552149" /><figcaption aria-hidden="true">image-20231208114552149</figcaption></figure><figure><img src="assets/数字电路.assets/三变量最大项编号表.png"alt="image-20231208114641914" /><figcaption aria-hidden="true">image-20231208114641914</figcaption></figure><h3 id="化简">化简</h3><h4 id="公式化简法">公式化简法</h4><p>用基本公式，常用公式，反复使用，化简，举例AB+AB'=A(B+B')=A</p><h4 id="卡诺图化简法">卡诺图化简法</h4><p>已知逻辑上相邻最小项可并项，设法使逻辑相邻的物理上也可相邻，直观由图反应，便可轻松知哪些可并项。</p><p>下图是两到五变量最小项卡诺图，规律显而易见。</p><p>如图（a)--&gt;(b)所示，在那边添加变量，向哪边扩展，理解成折叠的纸片展开(便于理解后面的相邻，实际上是格雷码。这只是一种理解记忆方式)，所以有横向01 折叠展开--&gt;0 1 1 0 --&gt; (0)1 (0)1 (1)1 (1)0。 <imgsrc="assets/数字电路.assets/两到五变量最小项卡诺图.png"alt="image-20231208115354221" /></p><p><strong>举例卡诺图化简：</strong></p><p>Y=A’B'C'D'+A'BD'+ACD+AB'=A'B'C'D+A'BCD'+A'BC'D'+ABCD+AB'CD+AB'CD'+AB'C'D+AB'C'D'=<spanclass="math inline">\(m_1+m_4+m_6+m_8+m_9+m_{10}+m_{11}+m_{15}\)</span>画成卡诺图如下图所示，解释一下，图中最小项之和中有m11——AB'CD，即1011，也就是横排10，竖排11，下图4行3列的位置填1，其余的m1等等同理填入。<img src="assets/数字电路.assets/卡诺图化简举例.png"alt="image-20231208154133146" /></p><p>化简时，可以轻易看出相邻的部分，图中同颜色圈住的地方（理解，折叠回二变量最小卡诺图时相邻的就是相邻最小项），所以可以将其化简回去得到Y=AB'+A'BD'+A'B'C'D'或AB'+A'BD'+ACD。</p><p>红色圈住的方块，先看横排，10(AB')是共有的，再看竖排，没有共有的，化简得AB'</p><p>灰色圈住的方块，先看横排，11与10共1(A)，再看竖排，11(CD)共有，化简得ACD</p><p>蓝色圈住的方块，先看横排，01(A'B)是共有的，再看竖排，00与10共0(D')，化简得A’BD‘</p><p>合起来得到Y=AB'+A'BD'+ACD</p><p><strong>卡诺图化简的其他例子可参考下图：</strong></p><figure><img src="assets/数字电路.assets/最小项相邻的几种情况.png"alt="image-20231208155635593" /><figcaption aria-hidden="true">image-20231208155635593</figcaption></figure><p><strong>从先前的例题可以知道，卡诺图化简的结果不唯一，但是最简式子的项数一定唯一（例题中都是三项之和）</strong></p><h4id="奎恩麦克拉斯基化简法q-m化简法">奎恩麦克拉斯基化简法(Q-M化简法)</h4><p>便于计算机编程实现的化简法 #### 无关项在逻辑函数化简中的应用<strong>约束项：</strong> 恒等于0的项（概率为0的事件）<strong>任意项：</strong> 取任何值都对电路毫无影响的项<strong>无关项：</strong> 约束项+任意项在理论设计中，电路可以毫无限制，但实际应用通常是有背景的，好比买电脑是在一定预算下考虑性价比，而非无脑上高配置。在这种情况下，就出现了约束项，无关项，可以引入以化简电路（中学数学中配方法等公式使用应当并不陌生，也是这样的化简的）<strong>相关证明：</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">逻辑函数通常表现为最小项之和Y=A&#x27;B+AB&#x27; ,如果AB=0,那么Y=A&#x27;B+AB&#x27; +AB是没有影响的（与0作或等于自身）</span><br><span class="line"></span><br><span class="line">对于任意项，书中举了个例子</span><br><span class="line">假设Y=AB&#x27;C&#x27;，已知A=B=C时切断电源，所以我们说ABC是Y的任意项</span><br><span class="line">ABC=1时，电源切断，对电路无影响，ABC=0时，与0作或等于没做。所以Y=AB&#x27;C&#x27;+ABC与先前是没什么区别的。</span><br></pre></td></tr></table></figure> <strong>举例</strong> <imgsrc="assets/数字电路.assets/无关项在逻辑函数化简中的应用.png" /></p><h2 id="门电路">门电路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">杂乱无章的听课笔记</span><br><span class="line"></span><br><span class="line">模拟信号有传播误差，累积下误差会极大，因而考虑数字信号传播信息。</span><br><span class="line">通常数字信号定义高电平为1，低电平为0，比如TTL电平标准认为低于0.8v为0，高于2.0v为1。</span><br><span class="line"></span><br><span class="line">电源可以连接二极管构成二极管开关电路，为了保护电源，电源通常会与一个大小合适的电阻串联，以保护电源。</span><br><span class="line"></span><br><span class="line">关于二极管与或门</span><br><span class="line">普通二极管正向导通通常认为其压降为0.7v(0.7v即导通，导通后二极管两端电压差为0.7V），所以图中二极管与门，A，B接3v,二极管都导通，故Y点电压为3.7V。A,B有一个接0V，电流基本从接0V这端过，Y点电压0.7V（原理没学，待补充）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;学习教材 &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    <category term="电工电子基础" scheme="http://example.com/categories/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>mini打印机项目</title>
    <link href="http://example.com/blog/28106.html"/>
    <id>http://example.com/blog/28106.html</id>
    <published>2023-12-11T09:24:13.000Z</published>
    <updated>2023-12-12T07:11:44.460Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="819d6a78cef8b81467377a08d536585cd2f42889667cc4ebef210a6a6dd9a2c6">161e93c4419f838fba4978c15eeea98b8592a5e8ef2838bf88ba9262c3ec0a4a5bab76e2b9b38177ee315ba6c8392d3e7d79b684c4941bbc7b6cff66fb835e69883ae32875f6c89ac7e7402935b1e5241c21f6c2f9923f1b397e1cdd03bb85f86fba41258ae57586661d6686a1f7b93367a5bf297cd50986f6df9f416080853353496dc7c858d682223c593e0e08dcebe91820104a36281c383624ada265ee513129420548bdb80da02141b664d73f0cf6e709f000cc462f4fe0dd95eaf995a83ece30586feac3fa9b4ec3ac4effc3ddfde671bc0d730af88a7b30380450cf9ccc4adf0b63c7334c0f465bab488c7e6f7794fc2cd1243c2e3355d69d1524db2df56852587ca2c30ff126f62bffe651aaf0f9ea197a0c9e94d2ed0878a445cfba332286fa5fc438f63d736b2a15c890ce490bb59d99238aed5f396b5a43b7a64fffc85639af19b0845e558eababe8081ca78533aa49926df052ce0460122d6e6291a8e673d5c192c77ab9273f4468a19c7a8ca21fa393253a7af2b95abfbb43b98ea7bdcfeb7abea9dd5201a8eeeb5051f690b65ea92d74a3636164f00382b29d0e0d2a71726163a4d489cd21468d99bc496a799f8195f9e83109c9aaf905d8896b095b3b8fb7e45391134b8d6f31654a361c727134af26b06f28c05ecd73d1785bdb2aa583f4d416fdd7030f9d723391e0d060728e414e142dc59c077f965ea3e9085d167bdbb6dadfd1bc72dedfc7c9dfe5df13239df2a243796e682045e8273b27198c73cd1dd31a8b60ad62b62b419958a0a30bc97cb3f103a5def172369481dcee20b2de8ed97a82c824e51adbc83b985ad54e38d40561aeb614c6aa4f9aee6ead5d545b6a8b06d6b3d17f1756a08741a75b88ad44cf31e9e9fd061c179922406d8e72a6ede3d8ed16c122fdf2be8004249c10b65490548603aed665048e34521fbbc90b098b635cf603ca90af5d5911a1713ff4c8a06af50ecd5321cfba508e76ac05abef006c5aa5098e2f315071d9c3df6bbed9c9083fc742834cf1ded2c3441503a57d532ff00ac3ddc38beeaefab19d5fc0517aaec4f9c70ca74d78f8d5d06b82ae4b860e8ec0833b270bf99b5997b23294e7d91e5fca97b7e9a87c97caba6d494a2aaa479a55943fd906f1f0ccd9820b865cc821d7afc0c834c89a7c51a41045e63e815bec9dc9c708629a9f3c3e38447756b18277c8198a01eb69490470ec10320b910529e4dc02fc9a52ce1b08494387a30a6da2313c745989bbefc9a96033eb3deb1b2146b79cb5ed485e0d5cfa3889122ee1fd62163aa6fe0ac88bb631bf59db800c08f21c0e521061d049147ab2415004e842ad81db2c2d7821a21bd6589b9ca2495c08cad78e007879b0d707e861b01d819c99427b031b0c188e29acedd9f4fb4abd15ea963266fb779f164db6c57b087070b55e20ea790162c8305d9998e44645c331bb78382f12835c09d826fd1286a1154dfa8a8c9cf1af65c5aa3088d20effba3ab1c7292e0383182c8cd0f00b3b07f05f1c92af44096f8391487daff5761570b57a8bcea447566822470534a6b74c14ecbbf0b64dfd0ff1a7c1cacf5418ffa4845f9ef1477d71a5e97a515aa5b74cbb128b96fdfcc82e1c8515b79afa8e43fc6cf28a999accf8f5a347700ba36b7ebe94ff8e8dae685379cf09cceac45362c2259849c35e1c28fb9df1b9e116ad50f61a02dc26ca5b1ef9cece095c0aa901bdbf187f794b627cb8847b2524f7d82701362b894f85349e45a6f91a81b548643616792263281d291f5b45cf06ce66569ff672a222eb76545310d24b29c7b4e70ba237d51e782ce5cc8a0016a7e557e0830a27f10ac674e8cbeab59cb112d7f251c0d110b3fe4445d50e04e171af700f94ef12ff16b0e3ec0bbfb4327fb51ce3d4ca0d9dccde180367340b64d8c06711411acec162d26d0c070e6f6a825ca239548ba5354fef4eb195dfcc06182581a262630149b1f2f427ea49c5b4eca4b6d0286b5784277879d5c5b25425121bf9447761f73af99865348162ef99afc2e0d1340a7d303a29eaafdfd1e4e101e7992e5e153918a4a0f2c5ffe6997dd1cff67608d8ba20897a8cb39dc8adb19eab4af688974aa1503541b78d8fc4db69efb86b909d7e96b14d3c617d7d1940acba84110b15ae77685a9c351678ea6dbd572f83e840e19e2dc11aa54754136899d1468b6365cff81fa1ad561eecab87f898bef8e1f150f61c0e520e9c726f50f5a95e14001dea808b36734a16a65cfabb13bc0c7d418fd47c8720dc633fe81cd91f0bf2be98b230500871ecd51433a859b7bcf65788902481b3a5d624da06275e28357b3bebac3d0944644f82f0bab6e67c5d0c9c66c578f21fb9d9040ed89ceb25646915f8a7dc24ed14672576afdfffaba39c97c23d162cec5bf32f89c5fe43122b7ec89d9e29dbd1807303cdeab56c832e2f833e8d2ee09a083b2219d104989c8e4532f40226c0d0d6d392f82cefeb604dea140bcf0dd49a0752f605e9673a6a437dc5d9b41cdd192470ba33fce71856585f0e23b1e94789bdeb874f0dcc925e4318d28d922a1719cdcb3c547b1e705186f05548dd044c6eb94690afdf49c7bddc1e7aa601557169e6a655db6d5ebd7ac775115e4c17da82bbc56f347be2794599c081297b2da28d7d908f2d518fe6f9dfbce356562732abe0127912baac254f22a2f81f8df010f7a90d457dda457abf020df9823d6de0ef8f4ad71d7985c2dc0b222fde7fdbf9a4d9cf9cbd9d16396229712568d98aa59982f1d7248327f83e296e0e1d6c30ba6c0014936347e86e60f9eaef289a55c97a223eb92e602806da9d10830fbbd33fe23527993c8c1ad11e4d88123d07921604027f233670136e713295f4245a3d41103bf787cff56160598e20f2e3f965dc48f4bc6cf12dba23e0e5d609ca90a8475eaa9923ed619718ecea383f0fee1509fe82fe7e56bd4a70b976806c5080976e2f2a0c879dd7c0ac7a9fabb9b1b6c462d2c6d5eac0bda8e8d54983d4978148c34fea1f2da6d9864d1501ea872157b2cf92b596d4fe9b820ff7d5282a902456ebf1274a1e7502916b117aaeeff00fb501042a28bd557fb621e00adaa8979f8ef5fb85f043a3c67fef0ff05bd9f4d812c6a34847648765ca48f2120cf44a410cb8e699f72d031c514b176a078eb7e0521fc54d8b2131eb6ad1ace3480a984ce9fdd2e45996becc5aa05be9d2b014b08027b4530333880e28d90ab3c17a9fa8e5ed998f81e5be65a753f4591098d394f4244c421de47987808f641f91d38f38944b1dd4ff9cebcf71deb56085521ea97acdc987ac7354d5b60ed6e0ff4c969c75f1693dff4ffb08f6260fff64b19e2bed705e6b653b9bddf84133023af5954632515d053f3e219eb67f913c2ab963ac92a27c97dddfe323cd39505c6dd47cc75233a56381e9cb0e4b83784bc6f00d425290a2e85e6de0264ff30d326494794b6a80e5faec94c3399b919d2b7b00f77d33820152736f52e5ae3d5cea33d554722630ce204afbe0fa97f75834ab56bfff88611b0b5185e0c27adea83503724020e62a89c7a168ddeafbfbd4b10338dc6651a6523c5838d494325d3062d6b6206d6ad75d026bb428da6c704c02cf0884dca2e2e1989b2ec2ff88a88578d195b95c769812aad4cfe4a6fe8e113fff0b704b2d558f6300a0d242a41fa34ecade60ff30eefbca734d3f4e695a96bb0bb802e4adf0c893a4affd6062aec1e67ffa9e982fe38101e66bf17d6f537b05db6087ab13195667ede5a611e2d150cdde467f651e9856f8a2ddb26c65d8534c0adec56963ac43bc6163f0522f00406848d7245d0c3d0d8ec5dab70d033d4cdaa8dde3eccf80fed06b210fba6fc2130f3f3c75475616d945a90c3096fb933c1b626e54b506e711b84d1a6eb74c8b318c1f979648b38743ff7f8a06b91e61ef85e6815addc5949dcf36d0b666d9d18910abe94f8a15a4054e6544543a4b2d7f79b0fcd1988b8185c3e7dc7eea6ceeb71b03656750903a28d313ab9f95cc9eecc5494aa926f265491570350c7f8b5f4cbf3147010bfad334fb0c17d07cfd9b8d1f2853879527d8ce6e66126f320c51ed742f670edb9a7d421d2f96c7e7abacf25ff7abb4f7b6d12bbc3ead90a2697e0194ca5b6e466e07e2378188737f70c5832c22cfbf4e45149af1737c57cef54f817a492646e7fb4920ae3f7c984057520a9a3c8130c59f4a0ba683d7cce4d5d5f6617f5583bd2b42ca7b328a6c2d7256b48aec9fa8eb18032df1c2b4f14c1ce6c9f4f944ff64f8577764facadd79063211fad77877860b44165cdc13d383b2d3c7e5c7cb537f10558e27d483d42dc74b32f569e21bb3340929b9ceb0df753401bffd6323132995e799dd565579b8506b350eb4d8fffcdfc3d1af2c4efdb6c2db32298467a6bb736b09371390fac8f93647b86ea4210773f7f97c1d58d35e22f957ed6664c0268cf54bf3ca7dfc522ad807cb79d8af1b5eec87fccd54f89c47ea0d84deef9757adf968d8c0a0b8d5cc0fe2dcf815ab634c29da7a8affa961a12ea51c1a955fcea51151c62b3a96800c1fdb7f00f17f06cdee3ef33b79f95c1d7386693a00a721aead87c0c12fced1bb71030c5a4dff0095d6e43352f3e0ea17a347e6e31451398ca75176e9e7ae9e5f3878e7a9d6afd48acdbb8865036a5a5ee97cb67d5ebcf2933f66cd2e8874862de63a6a1f0122ffcdc9f6d900a335e98b55f0d7f1be1bf500d160eca04ca604bb945d5e122615f69615e133fb57e0a85f00198a64853e327b874b07eaa55c0a3efa0d68a73364175a53a42bfa3344cfddbb483711f6a79c04eff06023007e37d4065b1885d632c617f2e5faef117ed7e3d379d143b63c7753e9acfde53b87051edfc29a7bb7a83782752af0cb144ded44cf4721d2ac3d74db46f85ea9e6128d961b6e52b98acdcd6d7c393c154355221766c660d1c4bc86e8301c4ca38b130a66950c7203e5976547f644942d0bcc1add74b6c15c77710a3eb8245462f703a5e720192869a2cc268a8b34ac6a34a763ddb6196922e313930c0891d8ab64e430195d1c4fbdc597cfa69ea748bb3e4d0c9b139fb8298d7aaed75345a11c31a00b3cb3089ec5112cb9bb6accdf1d0cd8856bc4c52bc4ad5bf5eb32fcc55f6cdad9cf6b3662277b86dbaa118f20c261933868a6732e52699b71107050c9e19d8a63ecb66e9cddcdb686d748fb4dfd947717d2915bb2ea562c4b5835223e91890f8ea9eea667ca0071eef32edf17628909e4565a634f1400e8fdd5523059b57bf1ff319ab68ecdb1ec0d1cf85bbdaf4f1efdc5b0c1a08fa905974dbbde168015d834fec8aa2f435b43cdf924bc713b2314dc230019a1a06141447b3aa45434de927dd2db88956001a248a2b8b87242be3dbd7dc3566dac8902f2bb2755baae06c8e6bbb78983d0605234eed9c071a8a55872b6a0962f8ca22ac3b053eedf3159ac2d7abb50f1a81da785b013ee0726c6bcac561388d8f811383f01b1d2d6188116bf65088c4a7cb7bbee1af686f13b488eb1db789ffb656b765c5ac20941fa7be68e9da4d29dec4fcc257012f88bb88337af7c402c6c49f22bf7491d9c0fd3b57572690b2cb4f88bce2142137033db4430dd77cebc371d58c925e4a8506d6efa6fb888745ae7e504ecfe955c1359e90a9d2d0913036a49aa62277d731f779ffcee1c6dbbb7943570761a07545c16074cba9bd27cc3b711b9b7f0dc2123893bbd560f04c5f166469ec5d56030be29862a7e8687d986d8c1338a9637abf75288e658d7ccfd838ec3645e249679dcc248a25aaa8bf8430709d8ea2ec50f1f8f708f1274587b8bd4c3cdc806a6d9bc9f44ca3502174205ead6141e15987f4e2c04dbc6efb123fcce10faa8dd5588c2fecd2aa40df33b0a779f348a621c7d55afaab60866f280d5908ee9a6d76b45d4cd26631d7ee5e034c280b05bd9a387946ba30dcd36f7a1ac5f2c6ac30ed73cf3a091ad7d9d08f278de1848cd7fd69c21411547ae8dbd3d480a72e6129504e4861761b1117c0fb8fa29dc005f15da133c2c3d760ef3d83b2c61359bc9531aa7aa99e933b0f92e3e7e5995276e2361ac60ff5b3a9c5bb1d822c5ada04096c378eefb3373432bad1f69fb1bc9c41b97922463671712222ddb4ff312cc8f0e73c45d4b7bcfc4042132fbd0a5e8ebeaa0d9e63c697a95335f1ebabdb5b4cc6998d60a02f9ddf4953de24764a2c6ffb3a8f011e294bd0a1c10fc70fac7fd4cb0560622ca6c038b71dcec00f286be111d189eb1f8593fe25cced34b09e5ba6fddc1eb77a55b44b629bf2a36d1c2940b3937a69fbacab293b2297bd70ceec1244867dd8047ca2d1f7671b68c07373f4d8faa5effd931b9a447ffe57a2563379732c2f52a77a933343471c0329f5a0b3c646efb09a226993c16727bc8c9736a91d2c2f9b17e086da4cdbdd9a02a614860813ea1080a6c903cfbbf7c964cbc02c96061b8d4425ecae4796f46321b7dc28824a18557ab16826f98f0a1e7f6e495632915e88bb3128277e3e94273d32643e2663c4c0ea1e43a8a14f5e18207a27485b91e7b983fa1eb173e3a222b5a94a97c62b096db934475d4fb7945c2fc49ce383cf0f53a8cf2bf7151561e8bd06899011269b20d95462579a4481bfcc6be02cc71ea5e7e0037b9a952809d0007beebbdbf5b9dfb68d6fb6de0a6c18fd562f99bf7a43d83f5b00951a700a36bf0344a5a9b4bec447354f9656c22912da62327de9d9c1265c533144416d7c5eeeff88044b63c7b3cac4f70a1e81a1bc98663416dc5ba75996df2cb948a37097fa50f15c50f086ce2c29271e58bef618aad7163b90f30235b27e3dffbf9b502fbeee7930ab9f0a1b4ed8b29fa3bc9d0ee0c49bd4fd056963d406a293385902c0d4962c5837a33ef7c971e0b750cc58f6e4b256af328a5554d471ab47968545127f96b49ce436fe08047ea4172171ba4cd025f3342141ea1df6364e01c825e68200b0c5b33a2afff75db3a4d4d3d6452fd39787c085b44f03ac4ce5ce17e96ddbd5d24900e32c3c31652dc1384e6d9b7ace7af62f68374d9725702d30fc860ae68a6675cc6781140dd748c13deb6064cd0d88bffd2d797a8315880f700255ebd224c04bc0ce5ee0fd3dac8b2457ddf34b0f0b9ae27062c2ea61fbb15a30f6405e1cb45667f28866906ed175ea35eb7e15ffcdff0d52509e5a3564c02ad97bb90f6d4ce8397742bd81515de3c77f8773232fa1d543bf0492846c5841d851ac672bce6142fba9bf202150972894c737abbdcd992852e6563b79a3bbb3f2c59d4fad3f477e5eb95453497f14b153d1ccbe007b8f3254b5f6fac18f055d95eefc38d3e829837221215930af6ead9f37e202ed63466f8d9c64844caabf2c0737dcbf1b9bb04d5b4d1d69ffd8add752029d8644e98724189b41e21792d02c3616abebe8cb03eef47ab82ec1ea8da408634e3c63bd8bda391e3869f071141088b780562aac0dc8c3879699267a467819f074c8a486132b0a77207c5be9bfc2cb98220ce2249b81d3300a0cd1c7264973a6b003e9ac55d817d93097749352b95509407c748f3f251a81d0bbb963e6b85b98e22ad0e3123f6b38d808e62429a59219cdcdfd7f726a4e7ce1ec99fd35afb09015a08aee6cf1963de76ff84cf2c56a63dad7a72e11fe6e35252252726c15581bd448f9d353408ac2ece54ad9f5008a9ef5ae459de241061cd8918d441555e8b066884cd58c45581c8894f24f235005960c11ae41dca903c10e651a8a997fd8a8fe9a810045940d118a5bef27ed1e369c6810e2ced4abd7c7590962ef3be9a0fd33ec161ff76d07bad17333742ed9ac33b7fc8779b1d6ee23dff27c0fe8f8aaf2ad83f6aeda100c6a1e156ee58ea707ee67fc082b90f1336631d94aee09967fb4a53ed5a8486db7a65577d3a3f8655f8e1e9623fe6e3b49b7aa023fb54be2dd5f0248b5c50b899ea04400d1535a5442728a19ee98b4eaa0c284a970dfcba9597742ccb825e52376a1766e01a1cf6b5fde58e4706776dce6ff70ba44fe082acc74eb4a97473785dd06e6f635ca49ddd08aea4ce086e71a60dac55edb1aa285e71f1af3893c564ee9b7336769145a1d875b01f8cab281d5e05bed1954996f020913eb860e51cdf928bf0363c462632adf8657c451e418b08b5bb508a33079a6de120a6df86cfbde9fa2448ca4b66c761169ca290458d6feed22dc3cf270eeba2bd0e370e1a07483228f05bf9b9855057f469781f723999d325732b7bf2a9b55e2a17776b1b876ea7f59d59fc74c71bccae95e58698fa81fceba7421009f10f9af67c073159b4fe71078c4e94bccdd6ded666708ac14d3f44ffad46606c716bd6e7d15c9eee01507261b6c848426d49656f0f329f45bcf798fc04ab6e513decde02f6e6b249bc7143cb1cb8f9c0de82196ad623441f85abcf1cff821907a6cd60d772f8a0fd56437fb6715e1107f3a426a962c22931a8ed2182c35c32aef1730b60d75d3fe90db5773490b69e319dada2e69a94a473b0dd6e426d9236dc6d0e201b700384b354ec0a31bd580fb9bd3ddaee12f87f119396c7463c91259e2ec30d8ac5eafeb9b67c65f06ba89618a814fa00a08c1a919ff3e34d8ef04f6ec1c8e1c6ad1d218977c16aaa4cd0b329f63b4ee15f9896b2a039336ada05cb7fc767f693f1f3497c576d820d37361f3d31b92de68713fba23aa0b710265d095f7d27cac8d0a7df8e001a614153a996cfc4a8b44276ac041efb96f3ec688ed5e075485caf5aeba05ce31aca39ce6516e958cf1d6192939a509b6adca7b166e3a04b78049a928747fb1dfe42c9eb67c380af47b298ed1f91e75c93945b8cf51c2e67360a0548f1f99a39640bcac19474e1f328e60bd1cdbd3761789cb13d8b422df97c8bd6677f0d082f3781b2ea9e78e4e349ad13d89d1e84a620b8c0caddcbaed42abf385c45ba4a22b08ba01da045e4ed056e9e6f0614caccbd6954a7fd1ecf67030cb2a137ab8598e6f1c2bfa0e1fa4d007861d9fbbd5f86fdf43b1b00b484887ce1acacd36740b2ee60e9a42a270acd3a66a77c56390e2922bb3aa8b460285e9f06081e3d732aac1d235e27674839cceaade1a46001a506ba46df261589769ca64207b931afc338375c2f5f1a264f91d84dd6dd232ae2218a4293ff3c58925ebdcee14e76d0764a59cc39d2954bc72b5cba6d1afee351dd8be279c35c34c82c2f0b6e88581366903b0fa46aef6ea28092b79506ad219caf216ae9aab4d741181a2f9e853e9be001599610f217387fe705251e89b1cb1bbd1cfa4e7bf03cac1285ed98d1d2fdeadaf825ce288bdf7457c18c69a78b6084ddf5a0e887960f69e2604e3f2dcabee8f271898b2e0a587966f9b68a131f3cda1a79a56deabc31b4b26b5db6e0342582135eb8c28a2b902458bb1770fe112bdc8d27fb24ab1009e7fe98526696b30c217243f222b2945b0db0a80668c42af6f4a68d1cb5755d04788e843c9924ebb79c0c26a80e152501bcd6a8cb7a3feeab0bddcfcb366f6afa09cbf64e5e4e18d135e27719aff4bc59352a2474ba1ec9173e3c87e97e488beb8d7b2e993d7bdcb9d4ebf12cf70853f7be6017a1873d4c6f66528ecb9d798d2d78f7ef27dbd7fee5ee4de73855b81570b8883a8fc1c4071dc4ae1d182648d6cbbcb4d53c6ea5ebb55c90713cf336285bb928d4179d938646ace67b5d4087fc60b43dd50a0640351200965d5b126a6554832e2deec9ecc271c7c9f8a7ecfd537aa5e438a430b7093a931fab31c599521f5e5ca96c0f410145bbc65e98dcd311b4c672a8d4154b69ad22c5eb6be29a6f803eb7f3abc3a047ac38dd3e9df7ecbe70e2c78ac47e0f0a391a2492bfa5ec9dcc0fa793199e5e7157ec8681c35695813986b68cdff7ecbd47b4911680da8df822d80bb7adb34147e3172280d5d6b21f4e30395bbb118bbe4f13dec0c5f2c546d8c7aa1b7b2629c3be81e57958da88fe425cba4cc106208b84b89631b76dc18f3dd7a805a198fb4553c308a03d0c39f12e9309da349c8c5db702b4c9ec63488e087fd44e779559f621ed24fb0a1ea24f70e1136f6815e3783590b7fa8b1abbda32c8de3a2af47cda0f2fce9828a87e4a5793fc06a70056a19bd98aba6462fe44a808af787ffcda26a2d0feb894da177ff1905902c88c67fb3eb99e847191cfcf41752bb1ef1792eefeb8cf15b859e027e625863369a691e6d099578551e65e67439954a0a7527a7863e12d164f1f393ec3c808748c67f852a4f7f9266b1b87c605f5fdd35c9fad5bb92beedd3af09d613a4c77e004ffc5756e421b44b3c8e39e042bd731384cdbcd28467bdf74b05d829fd8ab6657a816c90562908b98066a24fecc77e4238ecf34a68233e13b358c0e9c43d13fac6c0db303c6e94b26475039d4d3db01c62485a85e0c6c3eaa2bee53a4e930c6e0513e915a3d48b67a6e33056a17b948ca0c4ec25b0c4214149c1840bff5d23ad3ca8e6c3d9c31fba268102fab6666d308bc14033f9a07ac000fb23a0640809710ccce269b5eb1b9bd0fd52380e6e4dccac974fcd2d1d8cde608290ce6c475e4c2e2e7d4861801724de8c1acaa98a0ced0840fdce2983e8a2e37629bf6bb371bca448b30aaa022ec886eb9a849c2021cac5dbdabdc1a2f90129cd78d2aa7f06eedebeb65446efe41aa42cf65077ca61c5317d9ff78677d2a9a57fc6edaf1c87ce79e8a50750647bc4d544552b93c6377dfebe311ccb4fce3e232f539206dd9b9fe3e326d72b70d9911dd3d07a65afb7fe351a20c281a0933e69bb995ca1b556755e9ca6f8bbf6b9f191265ced1b770d10302d343aebcaf0196e92a958eeb62df372c9e7cb15907d60b359983f24e530a4ab56d1d0bee1a08a0137862e55ab8ce8d826d091bfa26dd722c5891c01dda</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这些是草稿或不便于观看的内容，需要密码。</summary>
    
    
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="个人项目" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="草稿" scheme="http://example.com/tags/%E8%8D%89%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/5.html"/>
    <id>http://example.com/blog/5.html</id>
    <published>2023-12-08T02:18:18.564Z</published>
    <updated>2023-12-12T07:36:21.848Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="各类语言" scheme="http://example.com/categories/%E5%90%84%E7%B1%BB%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Latex" scheme="http://example.com/categories/%E5%90%84%E7%B1%BB%E8%AF%AD%E8%A8%80/Latex/"/>
    
    
  </entry>
  
  <entry>
    <title>Python脚本</title>
    <link href="http://example.com/blog/27456.html"/>
    <id>http://example.com/blog/27456.html</id>
    <published>2023-12-06T01:04:43.000Z</published>
    <updated>2023-12-06T01:05:48.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片批量处理">图片批量处理</h1><p>需求描述 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现有大量格式相同图片，需要做以下处理</span><br><span class="line">1、图片处理和排序</span><br><span class="line">首先，需要对一系列图片按照时间顺序重命名。</span><br><span class="line">对每张图片命名规则为：以图片的具体时间作为文件名，格式为“年月日_时分秒”，例如“20231203_074627.jpg”。</span><br><span class="line">2、文本提取与文件命名：   </span><br><span class="line">    从每张图片中提取文本。</span><br><span class="line">    将提取出的文本保存为文本文件，文件名与图片文件相对应，格式变为“.txt”，例如“20231203_074627.txt”。</span><br><span class="line">3、文本内容处理：  </span><br><span class="line">    提取的文本格式可能包含前置文本、多个标号和文本段落，以及后置文本。</span><br><span class="line">    需要处理文本，以便仅保留标号和相应的文本段落，移除前置和后置的无关文本。</span><br></pre></td></tr></table></figure></p><p>代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//图片处理</span><br><span class="line">import os  </span><br><span class="line">import shutil  </span><br><span class="line">from datetime import datetime, timedelta  </span><br><span class="line">  </span><br><span class="line">pic_dir = &#x27;C:/users/28577/Pictures/Screenshots/&#x27;  </span><br><span class="line">output_dir = &#x27;output/&#x27;  </span><br><span class="line">  </span><br><span class="line">if not os.path.exists(output_dir):  </span><br><span class="line">    os.mkdir(output_dir)  </span><br><span class="line">  </span><br><span class="line">pic_file_lists = os.listdir(pic_dir)  </span><br><span class="line">for pic_file in pic_file_lists:  </span><br><span class="line">    if &quot;renamed&quot; in pic_file:  </span><br><span class="line">        continue  </span><br><span class="line">    # 获取文件的创建时间  </span><br><span class="line">    file_creation_time = os.path.getctime(pic_dir + pic_file)  </span><br><span class="line">    # 将时间戳转换为日期格式  </span><br><span class="line">    date_str = datetime.fromtimestamp(file_creation_time).strftime(&#x27;%Y%m%d_%H%M%S&#x27;)  </span><br><span class="line">    # 构建新文件名  </span><br><span class="line">    new_file_name = date_str + &quot;.jpg&quot;  </span><br><span class="line">    # 检查是否存在重名文件，如果有，则逐秒增加时间  </span><br><span class="line">    while os.path.exists(output_dir + new_file_name):  </span><br><span class="line">        file_creation_time += 1  # 增加一秒  </span><br><span class="line">        date_str = datetime.fromtimestamp(file_creation_time).strftime(&#x27;%Y%m%d_%H%M%S&#x27;)  </span><br><span class="line">        new_file_name = date_str + &quot;.jpg&quot;  </span><br><span class="line">    # 复制文件到新位置并重命名  </span><br><span class="line">    shutil.copy(pic_dir + pic_file, output_dir + new_file_name)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图片批量处理&quot;&gt;图片批量处理&lt;/h1&gt;
&lt;p&gt;需求描述 &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="各类语言" scheme="http://example.com/categories/%E5%90%84%E7%B1%BB%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="http://example.com/categories/%E5%90%84%E7%B1%BB%E8%AF%AD%E8%A8%80/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>电子元件(带图)_一些简单电路</title>
    <link href="http://example.com/blog/51164.html"/>
    <id>http://example.com/blog/51164.html</id>
    <published>2023-12-03T03:21:39.000Z</published>
    <updated>2023-12-04T01:26:22.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光敏电阻">光敏电阻</h1><p><img src="assets/电子元件(带图)_一些简单电路.assets/光敏电阻.jpg" />光照增大，电阻减小。</p><h1 id="排针">排针</h1><p><img src="assets/电子元件(带图)_一些简单电路.assets/直插排针.jpg" />排针常见间距有2.54、2.00、1.27mm。</p><h1 id="led灯">LED灯</h1><p><imgsrc="assets/电子元件(带图)_一些简单电路.assets/红色LED灯.png" /></p><h1 id="电阻">电阻</h1><p><img src="assets/电子元件(带图)_一些简单电路.assets/电阻.jpg" /></p><h1 id="蓝白可调电阻">蓝白可调电阻</h1><p><imgsrc="assets/电子元件(带图)_一些简单电路.assets/蓝白可调电阻.png" /></p><h1 id="三极管">三极管</h1><h2 id="万用表测量三极管">万用表测量三极管</h2><p>三极管分为两种：NPN型与PNP型，其符号如下图所示。用万用表测量三极管好坏也很简单，我们知道PN结中P代表正极，N代表负极，那么将万用表打到二极管档位，两个表笔对3个脚共有6种测法，除却红表笔接N，黑表笔接P的两种测法有读数，其余均无读数，那么三极管是好的。<imgsrc="assets/电子元件(带图)_一些简单电路.assets/三极管及万用表测量.png" /></p><h2 id="三极管的导通">三极管的导通</h2><p>三极管的控制极的输入电流大小方向可以控制从输出极到输入极所流的电流大小。对于三极管的导通，我的理解性记忆如下：首先三极管符号图中画的实心箭头是电流流向，据此我补充出另外两脚的电流流向，所以容易得出，在NPN三极管中控制极接高电平电流导出，并由输入极端流向输出极，PNP三极管同理可得控制极接低电平导通。其实还可以发现一个记忆的点，NPN三极管的控制极接的是P型半导体对应接正极，也正好是高电平导通，然后根据这个可以画出实心箭头电流流向，画出三极管的电路符号。<imgsrc="assets/电子元件(带图)_一些简单电路.assets/image-20231203172522973.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;光敏电阻&quot;&gt;光敏电阻&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;assets/电子元件(带图)_一些简单电路.assets/光敏电阻.jpg&quot; /&gt;
光照增大，电阻减小。&lt;/p&gt;
&lt;h1 id=&quot;排针&quot;&gt;排针&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;assets/电</summary>
      
    
    
    
    <category term="电工电子基础" scheme="http://example.com/categories/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
